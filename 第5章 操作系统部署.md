# 第5章 操作系统部署

## 5.1 批量安装系统

### PXE网络安装环境

#### PXE原理与架构

**PXE (Preboot eXecution Environment) 工作流程**
```
┌─────────────────┐    1. DHCP Discover    ┌─────────────────┐
│   客户端       │  ────────────────────→ │   DHCP服务器     │
│  (网卡PXE)     │                         │   (dhcpd)        │
└─────────────────┘                         └─────────────────┘
         │                                           │
         │    2. DHCP Offer (IP+TFTP服务器)          │
         │  ←───────────────────────────────────────── │
         │                                           │
         │    3. TFTP获取启动文件                    │
         │  ────────────────────→                    │
         │                                           │
┌─────────────────┐    4. 下载内核和initrd   ┌─────────────────┐
│   TFTP服务器    │  ────────────────────→ │   客户端         │
│   (tftp-server) │                         │  (内存中启动)    │
└─────────────────┘                         └─────────────────┘
         │                                           │
         │    5. 启动安装程序                        │
         │                                           │
         │    6. HTTP/FTP获取安装文件               │
         │  ←───────────────────────────────────────── │
         │                                           │
┌─────────────────┐                               │
│   HTTP服务器    │                               │
│   (安装源)      │                               │
└─────────────────┘                               │
                                                    │
┌─────────────────┐    7. 完成系统安装              │
│   客户端        │  ←────────────────────────────── │
│  (新系统)       │                                 │
└─────────────────┘                                 │
```

#### DHCP服务器配置

**安装DHCP服务**
```bash
# CentOS/RHEL系统
yum install dhcp-server

# Ubuntu/Debian系统
apt-get install isc-dhcp-server

# 启动服务
systemctl enable dhcpd
systemctl start dhcpd
```

**DHCP配置文件 (/etc/dhcp/dhcpd.conf)**
```bash
# 全局配置
option domain-name "hpc.edu.cn";
option domain-name-servers 8.8.8.8, 8.8.4.4;
default-lease-time 600;
max-lease-time 7200;
authoritative;

# TFTP服务器配置
next-server 192.168.1.10;     # TFTP服务器IP
filename "pxelinux.0";        # PXE启动文件

# 子网配置
subnet 192.168.1.0 netmask 255.255.255.0 {
    range 192.168.1.100 192.168.1.200;
    option routers 192.168.1.1;
    option subnet-mask 255.255.255.0;
    option broadcast-address 192.168.1.255;

    # 为特定MAC地址分配固定IP
    host compute-001 {
        hardware ethernet 00:11:22:33:44:01;
        fixed-address 192.168.1.101;
    }

    host compute-002 {
        hardware ethernet 00:11:22:33:44:02;
        fixed-address 192.168.1.102;
    }
}

# 不同架构支持
class "pxeclients" {
    match if substring(option vendor-class-identifier, 0, 9) = "PXEClient";
    next-server 192.168.1.10;
}

# UEFI支持
class "pxeclients-efi" {
    match if substring(option vendor-class-identifier, 0, 16) = "PXEClient:Arch:00007";
    filename "pxelinux.efi";
}
```

**防火墙配置**
```bash
# 开放DHCP端口
firewall-cmd --permanent --add-port=67/udp
firewall-cmd --permanent --add-port=68/udp
firewall-cmd --reload

# 检查DHCP服务
systemctl status dhcpd
tail -f /var/log/messages | grep dhcp
```

#### TFTP服务器配置

**安装TFTP服务**
```bash
# CentOS/RHEL
yum install tftp-server xinetd

# Ubuntu/Debian
apt-get install tftpd-hpa

# 启用TFTP服务
systemctl enable tftp
systemctl start tftp
```

**TFTP配置 (/etc/xinetd.d/tftp)**
```bash
service tftp
{
    socket_type     = dgram
    protocol        = udp
    wait            = yes
    user            = root
    server          = /usr/sbin/in.tftpd
    server_args     = -s /var/lib/tftpboot
    disable         = no
    per_source      = 11
    cps             = 100 2
    flags           = IPv4
}
```

**TFTP根目录结构**
```bash
# 创建TFTP根目录
mkdir -p /var/lib/tftpboot/{pxelinux.cfg,boot}

# 设置权限
chmod -R 755 /var/lib/tftpboot
chown -R nobody:nobody /var/lib/tftpboot

# 目录结构
/var/lib/tftpboot/
├── pxelinux.0                 # PXE引导程序
├── pxelinux.cfg/              # 配置文件目录
│   ├── default               # 默认配置
│   └── 01-00-11-22-33-44-55   # MAC地址配置
├── boot/
│   ├── vmlinuz               # 内核文件
│   └── initrd.img            # 初始化镜像
└── images/                   # 安装镜像
    └── centos7/
        ├── vmlinuz
        └── initrd.img
```

#### HTTP/FTP安装源配置

**Apache HTTP服务器**
```bash
# 安装Apache
yum install httpd
systemctl enable httpd
systemctl start httpd

# 配置虚拟主机
cat > /etc/httpd/conf.d/hpc-install.conf << EOF
<VirtualHost *:80>
    ServerName install.hpc.edu.cn
    DocumentRoot /var/www/html/install

    <Directory "/var/www/html/install">
        Options Indexes FollowSymLinks
        AllowOverride None
        Require all granted
    </Directory>

    ErrorLog /var/log/httpd/hpc-install_error.log
    CustomLog /var/log/httpd/hpc-install_access.log combined
</VirtualHost>
EOF

# 重启Apache
systemctl restart httpd
```

**NFS安装源**
```bash
# 安装NFS服务
yum install nfs-utils

# 配置NFS导出
echo "/var/www/html/install *(ro,sync,no_root_squash)" >> /etc/exports

# 启动NFS服务
systemctl enable rpcbind nfs-server
systemctl start rpcbind nfs-server

# 验证NFS导出
exportfs -v
showmount -e localhost
```

### Kickstart自动化安装

#### Kickstart文件详解

**基本Kickstart结构**
```bash
# Kickstart文件示例 (/var/www/html/install/ks.cfg)
#version=RHEL9
# System authorization information
auth --enableshadow --passalgo=sha512

# Use network installation
url --url="http://192.168.1.10/install/centos9"

# Use text mode install
text

# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'

# System language
lang en_US.UTF-8

# Network information
network --bootproto=static --device=eth0 --gateway=192.168.1.1 \
        --ip=192.168.1.100 --nameserver=8.8.8.8 --netmask=255.255.255.0 \
        --activate
network --bootproto=dhcp --device=eth1 --onboot=off

# Root password (加密后)
rootpw --iscrypted $6$random_salt$hashed_password

# System services
services --disabled="postfix" --enabled="chronyd,sshd,NetworkManager"

# System timezone
timezone Asia/Shanghai --isUtc

# System bootloader configuration
bootloader --location=mbr --boot-drive=sda

# Clear the Master Boot Record
zerombr

# Partition clearing information
clearpart --all --initlabel

# Disk partitioning information
part /boot --fstype="xfs" --ondisk=sda --size=1024
part / --fstype="xfs" --ondisk=sda --grow --size=1
part swap --fstype="swap" --ondisk=sda --size=8192

# System authorization information
authconfig --enableshadow --passalgo=sha512

# Reboot after installation
reboot

# SELinux configuration
selinux --disabled

# Firewall configuration
firewall --disabled

# SELinux and firewall settings
selinux --enforcing
firewall --enabled --service=ssh

# Package selection
%packages
@^minimal-environment
@core
@development
chrony
wget
curl
lscpu
htop
iotop
perf
%end

# Post-installation script
%post
# 设置主机名
hostnamectl set-hostname $(hostname -s)

# 配置网络
echo "nameserver 8.8.8.8" > /etc/resolv.conf

# 配置时间同步
systemctl enable chronyd
systemctl start chronyd
chronyc sources -v

# 创建用户目录
mkdir -p /home/users

# 配置sudo权限
echo "%wheel ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers

# 禁用IPv6
echo "net.ipv6.conf.all.disable_ipv6 = 1" >> /etc/sysctl.conf
echo "net.ipv6.conf.default.disable_ipv6 = 1" >> /etc/sysctl.conf
sysctl -p

# 优化内核参数
cat >> /etc/sysctl.conf << EOF
# HPC优化参数
net.core.somaxconn = 65535
net.core.netdev_max_backlog = 5000
net.ipv4.tcp_max_syn_backlog = 65535
net.ipv4.tcp_fin_timeout = 30
vm.swappiness = 1
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5
EOF

# 安装完成后清理
rm -rf /tmp/*
%end
```

#### Kickstart变量和模板

**动态Kickstart配置**
```bash
# 使用模板生成不同节点的Kickstart文件
#!/bin/bash

# 节点配置
declare -A NODES=(
    ["compute-001"]="192.168.1.101:compute"
    ["compute-002"]="192.168.1.102:compute"
    ["gpu-001"]="192.168.1.111:gpu"
)

# 生成Kickstart文件
for node in "${!NODES[@]}"; do
    IFS=':' read -r ip role <<< "${NODES[$node]}"

    # 根据角色选择不同的包组
    if [[ "$role" == "gpu" ]]; then
        PACKAGES="@^minimal-environment @core @development nvidia-driver nvidia-cuda-toolkit"
    else
        PACKAGES="@^minimal-environment @core @development"
    fi

    # 生成Kickstart文件
    cat > "/var/www/html/install/ks-${node}.cfg" << EOF
#version=RHEL9
url --url="http://192.168.1.10/install/centos9"
text
keyboard --vckeymap=us --xlayouts='us'
lang en_US.UTF-8
network --bootproto=static --device=eth0 --gateway=192.168.1.1 \
        --ip=${ip} --nameserver=8.8.8.8 --netmask=255.255.255.0 \
        --hostname=${node} --activate
rootpw --iscrypted \$6\$salt\$hash
timezone Asia/Shanghai --isUtc
bootloader --location=mbr --boot-drive=sda
zerombr
clearpart --all --initlabel
part /boot --fstype="xfs" --ondisk=sda --size=1024
part / --fstype="xfs" --ondisk=sda --grow --size=1
part swap --fstype="swap" --ondisk=sda --size=8192
reboot
selinux --disabled
firewall --disabled
%packages
${PACKAGES}
chrony
wget
curl
%end
%post
hostnamectl set-hostname ${node}
systemctl enable chronyd
%end
EOF
done
```

#### PXE配置文件

**pxelinux.cfg配置**
```bash
# 默认配置文件 (/var/lib/tftpboot/pxelinux.cfg/default)
DEFAULT menu.c32
PROMPT 0
TIMEOUT 600
MENU TITLE HPC Cluster Installation

LABEL centos9_compute
    MENU LABEL Install CentOS 9 - Compute Node
    KERNEL boot/centos9/vmlinuz
    APPEND initrd=boot/centos9/initrd.img inst.repo=http://192.168.1.10/install/centos9 inst.ks=http://192.168.1.10/install/ks-compute.cfg

LABEL centos9_gpu
    MENU LABEL Install CentOS 9 - GPU Node
    KERNEL boot/centos9/vmlinuz
    APPEND initrd=boot/centos9/initrd.img inst.repo=http://192.168.1.10/install/centos9 inst.ks=http://192.168.1.10/install/ks-gpu.cfg

LABEL centos9_debug
    MENU LABEL Install CentOS 9 - Debug Mode
    KERNEL boot/centos9/vmlinuz
    APPEND initrd=boot/centos9/initrd.img inst.repo=http://192.168.1.10/install/centos9 inst.ks=http://192.168.1.10/install/ks-debug.cfg inst.debug

LABEL local
    MENU LABEL Boot from local drive
    LOCALBOOT 0
```

**MAC地址特定配置**
```bash
# 为特定节点配置固定设置
# /var/lib/tftpboot/pxelinux.cfg/01-00-11-22-33-44-01
DEFAULT centos9_compute
IPAPPEND 2

# /var/lib/tftpboot/pxelinux.cfg/01-00-11-22-33-44-02
DEFAULT centos9_gpu
IPAPPEND 2
```

### 系统镜像制作

#### 自定义系统镜像

**创建自定义镜像**
```bash
# 1. 准备基础环境
mkdir -p /opt/custom-image/{mnt,iso,custom}
cd /opt/custom-image

# 2. 挂载原始ISO
mount -o loop CentOS-9-x86_64-dvd.iso mnt/

# 3. 复制ISO内容
cp -r mnt/* iso/
cp -r mnt/.discinfo iso/

# 4. 创建自定义脚本
cat > custom/post-install.sh << 'EOF'
#!/bin/bash
# 自定义配置脚本

# 更新系统
dnf update -y

# 安装HPC相关软件
dnf install -y openmpi gcc gcc-c++ gcc-gfortran
dnf install -y htop iotop perf lscpu
dnf install -y chrony wget curl

# 配置SSH
systemctl enable sshd
systemctl start sshd

# 配置时间同步
systemctl enable chronyd
systemctl start chronyd
chronyc sources -v

# 优化内核参数
cat >> /etc/sysctl.conf << EOL
# HPC优化参数
net.core.somaxconn = 65535
net.core.netdev_max_backlog = 5000
net.ipv4.tcp_max_syn_backlog = 65535
net.ipv4.tcp_fin_timeout = 30
vm.swappiness = 1
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5
EOL

# 禁用IPv6
echo "net.ipv6.conf.all.disable_ipv6 = 1" >> /etc/sysctl.conf
echo "net.ipv6.conf.default.disable_ipv6 = 1" >> /etc/sysctl.conf

# 配置sudo权限
echo "%wheel ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers

# 创建用户目录
mkdir -p /home/users

# 清理临时文件
rm -rf /tmp/*
EOF

chmod +x custom/post-install.sh

# 5. 修改启动脚本
# 编辑isolinux/isolinux.cfg或grub.cfg，添加自动安装选项
```

**修改启动菜单**
```bash
# 编辑grub.cfg (UEFI模式)
# /opt/custom-image/iso/EFI/BOOT/grub.cfg

menuentry 'Install CentOS 9 - Custom HPC' --class fedora --class gnu-linux --class gnu --class os {
    linuxefi /images/pxeboot/vmlinuz inst.stage2=hd:LABEL=CentOS-9-x86_64-dvd quiet
    initrdefi /images/pxeboot/initrd.img
}

menuentry 'Install CentOS 9 - HPC Compute Node' --class fedora --class gnu-linux --class gnu --class os {
    linuxefi /images/pxeboot/vmlinuz inst.stage2=hd:LABEL=CentOS-9-x86_64-dvd inst.ks=http://192.168.1.10/install/ks-compute.cfg quiet
    initrdefi /images/pxeboot/initrd.img
}
```

#### 镜像验证和测试

**验证镜像完整性**
```bash
# 1. 检查ISO结构
isoinfo -l -i custom-centos9.iso

# 2. 验证启动能力
# 使用虚拟机测试
qemu-system-x86_64 -cdrom custom-centos9.iso -boot d -m 2048

# 3. 检查文件完整性
md5sum custom-centos9.iso > custom-centos9.iso.md5

# 4. 创建校验脚本
cat > verify-image.sh << 'EOF'
#!/bin/bash
ISO_FILE="$1"

if [ ! -f "$ISO_FILE" ]; then
    echo "Error: ISO file not found"
    exit 1
fi

# 检查MD5
if [ -f "${ISO_FILE}.md5" ]; then
    md5sum -c "${ISO_FILE}.md5"
    if [ $? -ne 0 ]; then
        echo "Error: MD5 check failed"
        exit 1
    fi
fi

# 检查启动信息
if ! isoinfo -i "$ISO_FILE" -x '/BOOT.CAT' > /dev/null 2>&1; then
    echo "Error: Invalid ISO structure"
    exit 1
fi

echo "ISO verification passed"
EOF

chmod +x verify-image.sh
./verify-image.sh custom-centos9.iso
```

## 5.2 配置管理工具

### Ansible自动化部署

#### Ansible基础配置

**安装Ansible**
```bash
# 使用pip安装（推荐）
pip install ansible

# 使用系统包管理器
yum install ansible          # CentOS/RHEL
apt-get install ansible      # Ubuntu/Debian

# 验证安装
ansible --version
```

**Ansible配置文件**
```yaml
# /etc/ansible/ansible.cfg
[defaults]
# 基本配置
inventory = /etc/ansible/hosts
remote_user = root
ask_pass = False
host_key_checking = False

# 连接配置
transport = paramiko
timeout = 30

# 并行配置
forks = 50

# 模块配置
gathering = smart
fact_caching = memory

# 日志配置
log_path = /var/log/ansible.log
log_level = info

[ssh_connection]
# SSH连接优化
pipelining = True
ssh_args = -o ControlMaster=auto -o ControlPersist=60s
control_path = ~/.ansible/cp/ansible-ssh-%%h-%%p-%%r
```

#### 主机清单配置

**静态主机清单**
```yaml
# /etc/ansible/hosts
[all:vars]
ansible_user=root
ansible_ssh_private_key_file=/root/.ssh/id_rsa

# 管理节点
[master]
master-node ansible_host=192.168.1.10

# 计算节点
[compute]
compute-[001:100] ansible_host=192.168.1.[101:200]

# GPU节点
[gpu]
gpu-[001:020] ansible_host=192.168.1.[201:220]

# 存储节点
[storage]
storage-[001:005] ansible_host=192.168.1.[221:225]

# 按角色分组
[hpc-compute:children]
compute
gpu

[hpc-storage:children]
storage

# 变量定义
[compute:vars]
node_type=compute
partition=default

[gpu:vars]
node_type=gpu
partition=gpu
gpu_count=4

[storage:vars]
node_type=storage
storage_type=lustre
```

**动态主机清单**
```python
# /etc/ansible/hosts.py
#!/usr/bin/env python3
import json
import sys

def get_inventory():
    inventory = {
        "_meta": {
            "hostvars": {}
        },
        "all": {
            "hosts": [],
            "children": ["ungrouped"]
        }
    }

    # 从数据库或配置文件读取主机信息
    hosts = [
        {"hostname": "compute-001", "ip": "192.168.1.101", "type": "compute"},
        {"hostname": "compute-002", "ip": "192.168.1.102", "type": "compute"},
        {"hostname": "gpu-001", "ip": "192.168.1.201", "type": "gpu"},
    ]

    for host in hosts:
        inventory["all"]["hosts"].append(host["hostname"])
        inventory["_meta"]["hostvars"][host["hostname"]] = {
            "ansible_host": host["ip"],
            "node_type": host["type"]
        }

        # 按类型分组
        if host["type"] not in inventory:
            inventory[host["type"]] = {"hosts": []}
        inventory[host["type"]]["hosts"].append(host["hostname"])

    return inventory

if __name__ == "__main__":
    if len(sys.argv) > 1 and sys.argv[1] == "--list":
        print(json.dumps(get_inventory(), indent=2))
    else:
        print(json.dumps({"_meta": {"hostvars": {}}}, indent=2))
```

#### Playbook编写

**基础系统配置Playbook**
```yaml
# system-config.yml
---
- name: Configure HPC Compute Nodes
  hosts: compute
  become: yes
  vars:
    timezone: "Asia/Shanghai"
    ntp_servers:
      - "0.centos.pool.ntp.org"
      - "1.centos.pool.ntp.org"

  pre_tasks:
    - name: Update package cache
      yum:
        update_cache: yes

  tasks:
    - name: Install base packages
      yum:
        name:
          - htop
          - iotop
          - perf
          - lscpu
          - wget
          - curl
          - chrony
          - tmux
          - screen
        state: present

    - name: Configure timezone
      timezone:
        name: "{{ timezone }}"

    - name: Configure NTP
      template:
        src: chrony.conf.j2
        dest: /etc/chrony.conf
        owner: root
        group: root
        mode: '0644'
      notify: restart chronyd

    - name: Enable and start chronyd
      systemd:
        name: chronyd
        enabled: yes
        state: started

    - name: Configure kernel parameters
      sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
      loop:
        - { name: "net.core.somaxconn", value: "65535" }
        - { name: "net.core.netdev_max_backlog", value: "5000" }
        - { name: "net.ipv4.tcp_max_syn_backlog", value: "65535" }
        - { name: "net.ipv4.tcp_fin_timeout", value: "30" }
        - { name: "vm.swappiness", value: "1" }
        - { name: "vm.dirty_ratio", value: "15" }
        - { name: "vm.dirty_background_ratio", value: "5" }

    - name: Disable IPv6
      sysctl:
        name: "net.ipv6.conf.all.disable_ipv6"
        value: "1"
        state: present

    - name: Configure SSH
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "^{{ item.regexp }}"
        line: "{{ item.line }}"
        backup: yes
      loop:
        - { regexp: "PermitRootLogin", line: "PermitRootLogin no" }
        - { regexp: "PasswordAuthentication", line: "PasswordAuthentication no" }
        - { regexp: "PubkeyAuthentication", line: "PubkeyAuthentication yes" }
      notify: restart sshd

    - name: Create users directory
      file:
        path: /home/users
        state: directory
        owner: root
        group: root
        mode: '0755'

  handlers:
    - name: restart chronyd
      systemd:
        name: chronyd
        state: restarted

    - name: restart sshd
      systemd:
        name: sshd
        state: restarted
```

**用户管理Playbook**
```yaml
# user-management.yml
---
- name: Manage HPC Users
  hosts: all
  become: yes
  vars:
    hpc_users:
      - name: researcher1
        uid: 1001
        group: hpc-users
        shell: /bin/bash
        ssh_key: "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQ..."

      - name: researcher2
        uid: 1002
        group: hpc-users
        shell: /bin/bash
        ssh_key: "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQ..."

    hpc_groups:
      - name: hpc-users
        gid: 1001
      - name: hpc-admins
        gid: 1002

  tasks:
    - name: Create HPC groups
      group:
        name: "{{ item.name }}"
        gid: "{{ item.gid }}"
        state: present
      loop: "{{ hpc_groups }}"

    - name: Create HPC users
      user:
        name: "{{ item.name }}"
        uid: "{{ item.uid }}"
        group: "{{ item.group }}"
        shell: "{{ item.shell }}"
        create_home: yes
        home: "/home/{{ item.name }}"
        password: "{{ 'defaultpass' | password_hash('sha512') }}"
      loop: "{{ hpc_users }}"

    - name: Set up SSH keys
      authorized_key:
        user: "{{ item.name }}"
        key: "{{ item.ssh_key }}"
      loop: "{{ hpc_users }}"

    - name: Configure sudo permissions
      lineinfile:
        path: /etc/sudoers
        line: "%hpc-admins ALL=(ALL) NOPASSWD: ALL"
        validate: 'visudo -cf %s'
      check_mode: yes

    - name: Set up user environment
      template:
        src: bashrc.j2
        dest: /home/{{ item.name }}/.bashrc
        owner: "{{ item.name }}"
        group: "{{ item.group }}"
        mode: '0644'
      loop: "{{ hpc_users }}"
```

### Puppet配置管理

#### Puppet基础配置

**安装Puppet**
```bash
# 安装Puppet Server
yum install puppetserver
systemctl enable puppetserver
systemctl start puppetserver

# 安装Puppet Agent
yum install puppet
systemctl enable puppet
systemctl start puppet
```

**Puppet配置文件**
```ruby
# /etc/puppetlabs/puppet/puppet.conf
[main]
logdir = /var/log/puppetlabs/puppet
vardir = /opt/puppetlabs/server/data/puppetserver
ssldir = /etc/puppetlabs/puppet/ssl
rundir = /var/run/puppetlabs
factpath = $vardir/lib/facter
prerun_command = /usr/local/bin/puppet-update
postrun_command = /usr/local/bin/puppet-post-run

[master]
# Only the puppet master service
ssldir = /etc/puppetlabs/puppet/ssl
reports = puppetdb
storeconfigs = true
storeconfigs_backend = puppetdb
environmentpath = /etc/puppetlabs/code/environments
basemodulepath = /etc/puppetlabs/code/modules
```

#### Puppet模块编写

**HPC基础配置模块**
```ruby
# /etc/puppetlabs/code/modules/hpc_base/manifests/init.pp
class hpc_base {
  # 基础包安装
  class { 'hpc_base::packages':
    ensure => present,
  }

  # 内核参数配置
  class { 'hpc_base::sysctl':
    parameters => {
      'net.core.somaxconn'           => '65535',
      'net.core.netdev_max_backlog'   => '5000',
      'net.ipv4.tcp_max_syn_backlog'  => '65535',
      'net.ipv4.tcp_fin_timeout'      => '30',
      'vm.swappiness'                 => '1',
      'vm.dirty_ratio'                => '15',
      'vm.dirty_background_ratio'     => '5',
    },
  }

  # SSH配置
  class { 'hpc_base::ssh':
    permit_root_login => false,
    password_auth     => false,
    pubkey_auth       => true,
  }

  # 时间同步配置
  class { 'hpc_base::ntp':
    servers => [
      '0.centos.pool.ntp.org',
      '1.centos.pool.ntp.org',
    ],
  }
}

# 包管理类
class hpc_base::packages {
  $packages = [
    'htop',
    'iotop',
    'perf',
    'lscpu',
    'wget',
    'curl',
    'chrony',
    'tmux',
    'screen',
  ]

  package { $packages:
    ensure => present,
  }
}

# 内核参数类
class hpc_base::sysctl (
  Hash $parameters = {},
) {
  create_resources('sysctl', $parameters)
}

# SSH配置类
class hpc_base::ssh (
  Boolean $permit_root_login = false,
  Boolean $password_auth     = false,
  Boolean $pubkey_auth       = true,
) {
  file_line { 'ssh_permit_root_login':
    path  => '/etc/ssh/sshd_config',
    line  => "PermitRootLogin ${$permit_root_login ? { true => 'yes', default => 'no' }}",
    match => '^PermitRootLogin',
  }

  file_line { 'ssh_password_auth':
    path  => '/etc/ssh/sshd_config',
    line  => "PasswordAuthentication ${$password_auth ? { true => 'yes', default => 'no' }}",
    match => '^PasswordAuthentication',
  }

  file_line { 'ssh_pubkey_auth':
    path  => '/etc/ssh/sshd_config',
    line  => "PubkeyAuthentication ${$pubkey_auth ? { true => 'yes', default => 'no' }}",
    match => '^PubkeyAuthentication',
  }

  service { 'sshd':
    ensure => running,
    enable => true,
    subscribe => [
      File_line['ssh_permit_root_login'],
      File_line['ssh_password_auth'],
      File_line['ssh_pubkey_auth'],
    ],
  }
}

# NTP配置类
class hpc_base::ntp (
  Array $servers = ['0.centos.pool.ntp.org', '1.centos.pool.ntp.org'],
) {
  file { '/etc/chrony.conf':
    ensure  => file,
    content => template('hpc_base/chrony.conf.erb'),
    notify  => Service['chronyd'],
  }

  service { 'chronyd':
    ensure => running,
    enable => true,
  }
}
```

**模板文件**
```erb
<!-- /etc/puppetlabs/code/modules/hpc_base/templates/chrony.conf.erb -->
# HPC NTP Configuration
server <%= @servers[0] %> iburst
server <%= @servers[1] %> iburst

driftfile /var/lib/chrony/drift
makestep 1.0 3
rtcsync
logdir /var/log/chrony
```

### Chef配置管理

#### Chef基础配置

**安装Chef**
```bash
# 安装Chef Server
wget https://packages.chef.io/files/stable/chef-server/14.14.7/el/8/chef-server-core-14.14.7-1.el8.x86_64.rpm
rpm -Uvh chef-server-core-14.14.7-1.el8.x86_64.rpm
chef-server-ctl reconfigure

# 安装Chef Workstation
wget https://packages.chef.io/files/stable/chef-workstation/22.5.797/el/8/chef-workstation-22.5.797-1.el8.x86_64.rpm
rpm -Uvh chef-workstation-22.5.797-1.el8.x86_64.rpm
```

**Knife配置**
```ruby
# ~/.chef/knife.rb
current_dir = File.dirname(__FILE__)
log_level                :info
log_location             STDOUT
node_name                "admin"
client_key               "#{current_dir}/admin.pem"
validation_client_name   "chef-validator"
validation_key           "#{current_dir}/chef-validator.pem"
chef_server_url          "https://chef-server.example.com/organizations/hpc"
cookbook_path            ["#{current_dir}/../cookbooks"]
```

#### Chef Cookbook编写

**HPC基础Cookbook**
```ruby
# cookbooks/hpc_base/metadata.rb
name 'hpc_base'
maintainer 'HPC Admin'
maintainer_email 'admin@hpc.edu.cn'
description 'Installs and configures HPC base environment'
long_description IO.read(File.join(File.dirname(__FILE__), 'README.md'))
version '1.0.0'

%w(centos redhat ubuntu debian).each do |os|
  supports os
end

depends 'yum'
depends 'apt'
```

**默认属性**
```ruby
# cookbooks/hpc_base/attributes/default.rb
default['hpc_base']['packages'] = [
  'htop',
  'iotop',
  'perf',
  'lscpu',
  'wget',
  'curl',
  'chrony',
  'tmux',
  'screen',
]

default['hpc_base']['sysctl']['net.core.somaxconn'] = '65535'
default['hpc_base']['sysctl']['net.core.netdev_max_backlog'] = '5000'
default['hpc_base']['sysctl']['net.ipv4.tcp_max_syn_backlog'] = '65535'
default['hpc_base']['sysctl']['net.ipv4.tcp_fin_timeout'] = '30'
default['hpc_base']['sysctl']['vm.swappiness'] = '1'
default['hpc_base']['sysctl']['vm.dirty_ratio'] = '15'
default['hpc_base']['sysctl']['vm.dirty_background_ratio'] = '5'

default['hpc_base']['ntp']['servers'] = [
  '0.centos.pool.ntp.org',
  '1.centos.pool.ntp.org',
]
```

**主Recipe**
```ruby
# cookbooks/hpc_base/recipes/default.rb
include_recipe 'hpc_base::packages'
include_recipe 'hpc_base::sysctl'
include_recipe 'hpc_base::ssh'
include_recipe 'hpc_base::ntp'
include_recipe 'hpc_base::users'

# Cookbook:: hpc_base
# Recipe:: packages

package node['hpc_base']['packages'] do
  action :install
end

# Cookbook:: hpc_base
# Recipe:: sysctl

node['hpc_base']['sysctl'].each do |param, value|
  sysctl_param param do
    value value
    action :apply
  end
end

# Cookbook:: hpc_base
# Recipe:: ssh

file '/etc/ssh/sshd_config' do
  content lazy {
    IO.read('/etc/ssh/sshd_config').gsub(/^#?PermitRootLogin.*/, 'PermitRootLogin no')
                         .gsub(/^#?PasswordAuthentication.*/, 'PasswordAuthentication no')
                         .gsub(/^#?PubkeyAuthentication.*/, 'PubkeyAuthentication yes')
  }
  notifies :restart, 'service[sshd]'
end

service 'sshd' do
  action [:enable, :start]
end

# Cookbook:: hpc_base
# Recipe:: ntp

package 'chrony'

template '/etc/chrony.conf' do
  source 'chrony.conf.erb'
  variables(
    servers: node['hpc_base']['ntp']['servers']
  )
  notifies :restart, 'service[chronyd]'
end

service 'chronyd' do
  action [:enable, :start]
end

# Cookbook:: hpc_base
# Recipe:: users

group 'hpc-users' do
  gid 1001
  action :create
end

group 'hpc-admins' do
  gid 1002
  action :create
end

# 创建用户
node['hpc_base']['users'].each do |user_config|
  user user_config['name'] do
    uid user_config['uid']
    gid user_config['group']
    shell user_config['shell']
    home "/home/#{user_config['name']}"
    password user_config['password']
    action :create
  end

  directory "/home/#{user_config['name']}" do
    owner user_config['name']
    group user_config['group']
    mode '0755'
    action :create
  end

  file "/home/#{user_config['name']}/.ssh/authorized_keys" do
    content user_config['ssh_key']
    owner user_config['name']
    group user_config['group']
    mode '0600'
    action :create
  end
end
```

## 5.3 系统镜像制作

### 定制化系统镜像

#### 基于Kickstart的镜像定制

**创建定制镜像脚本**
```bash
#!/bin/bash
# create-custom-image.sh

set -e

# 配置变量
ISO_SOURCE="CentOS-9-x86_64-dvd.iso"
ISO_TARGET="custom-centos9-hpc.iso"
WORKDIR="/opt/custom-image"
MOUNT_POINT="$WORKDIR/mnt"
ISO_CONTENT="$WORKDIR/iso"
CUSTOM_SCRIPTS="$WORKDIR/custom"

# 创建工作目录
mkdir -p "$WORKDIR" "$MOUNT_POINT" "$ISO_CONTENT" "$CUSTOM_SCRIPTS"

# 挂载原始ISO
echo "Mounting source ISO..."
mount -o loop "$ISO_SOURCE" "$MOUNT_POINT"

# 复制ISO内容
echo "Copying ISO contents..."
cp -r "$MOUNT_POINT"/* "$ISO_CONTENT"/
cp -r "$MOUNT_POINT"/.* "$ISO_CONTENT"/ 2>/dev/null || true

# 创建自定义脚本
cat > "$CUSTOM_SCRIPTS/post-install.sh" << 'EOF'
#!/bin/bash
# HPC系统后安装配置脚本

set -e

echo "Starting HPC system configuration..."

# 1. 更新系统
echo "Updating system..."
dnf update -y

# 2. 安装HPC相关软件包
echo "Installing HPC packages..."
dnf install -y \
    openmpi \
    gcc \
    gcc-c++ \
    gcc-gfortran \
    mpich \
    intel-mpi \
    nvidia-driver \
    nvidia-cuda-toolkit \
    htop \
    iotop \
    perf \
    lscpu \
    chrony \
    wget \
    curl \
    tmux \
    screen \
    git \
    subversion \
    make \
    cmake \
    autoconf \
    automake \
    libtool

# 3. 配置时间同步
echo "Configuring time synchronization..."
systemctl enable chronyd
systemctl start chronyd
chronyc sources -v

# 4. 配置SSH
echo "Configuring SSH..."
systemctl enable sshd
systemctl start sshd

# 5. 优化内核参数
echo "Optimizing kernel parameters..."
cat >> /etc/sysctl.conf << EOL

# HPC Optimization Parameters
# Network optimization
net.core.somaxconn = 65535
net.core.netdev_max_backlog = 5000
net.ipv4.tcp_max_syn_backlog = 65535
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_timestamps = 1
net.ipv4.tcp_sack = 1

# Memory optimization
vm.swappiness = 1
vm.dirty_ratio = 15
vm.dirty_background_ratio = 5
vm.dirty_expire_centisecs = 500
vm.dirty_writeback_centisecs = 100

# File system optimization
fs.file-max = 1000000
EOL

sysctl -p

# 6. 禁用IPv6（可选）
echo "Disabling IPv6..."
echo "net.ipv6.conf.all.disable_ipv6 = 1" >> /etc/sysctl.conf
echo "net.ipv6.conf.default.disable_ipv6 = 1" >> /etc/sysctl.conf

# 7. 配置sudo权限
echo "Configuring sudo permissions..."
echo "%wheel ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
echo "%hpc-admins ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers

# 8. 创建必要的目录结构
echo "Creating directory structure..."
mkdir -p /home/users
mkdir -p /opt/hpc
mkdir -p /opt/mpi
mkdir -p /opt/compiler

# 9. 配置环境变量
echo "Configuring environment..."
cat >> /etc/profile.d/hpc.sh << 'EOL'
# HPC Environment Variables
export PATH=/opt/mpi/bin:\$PATH
export LD_LIBRARY_PATH=/opt/mpi/lib:\$LD_LIBRARY_PATH
export MANPATH=/opt/mpi/share/man:\$MANPATH

# OpenMP Settings
export OMP_NUM_THREADS=\$(nproc)
export OMP_PROC_BIND=TRUE
export OMP_PLACES=cores

# MPI Settings
export MPI_BUFFER_SIZE=1048576
EOL

# 10. 清理临时文件
echo "Cleaning up..."
rm -rf /tmp/*
rm -rf /var/tmp/*

echo "HPC system configuration completed!"
EOF

chmod +x "$CUSTOM_SCRIPTS/post-install.sh"

# 修改启动脚本以包含自定义配置
echo "Modifying boot configuration..."

# 备份原始配置
cp "$ISO_CONTENT/isolinux/isolinux.cfg" "$ISO_CONTENT/isolinux/isolinux.cfg.bak"

# 创建新的启动菜单
cat > "$ISO_CONTENT/isolinux/isolinux.cfg" << 'EOF'
default vesamenu.c32
timeout 600

display boot.msg

menu background splash.jpg
menu title Welcome to CentOS 9 HPC Edition
menu color border * #ffffffff #00000000 none
menu color sel 0 #ffffffff #00000000 none
menu color title 0 #ff7ba3d0 #00000000 none
menu color tabmsg 0 #ff3a6496 #00000000 none
menu color unsel 0 #ffffffff #00000000 none
menu color hotsel 0 #ff7ba3d0 #00000000 none
menu color hotkey 0 #ffffffff #00000000 none
menu color help 0 #ff7ba3d0 #00000000 none
menu color timeout 0 #ffffffff #00000000 none
menu color timeout_msg 0 #ffffffff #00000000 none
menu color cmdmark 0 #ffffffff #00000000 none
menu color cmdline 0 #ffffffff #00000000 none

menu tabmsg Press Tab for full configuration options, Enter to boot or c for command-line mode

# Default boot entry
label linux
  menu label ^Install CentOS 9 HPC Edition
  kernel vmlinuz
  append initrd=initrd.img inst.stage2=hd:LABEL=CentOS-9-x86_64-dvd quiet

label check
  menu label Test this ^media & install CentOS 9 HPC Edition
  kernel vmlinuz
  append initrd=initrd.img inst.stage2=hd:LABEL=CentOS-9-x86_64-dvd rd.live.check quiet

label linux-auto
  menu label ^Automatic Install CentOS 9 HPC Edition
  kernel vmlinuz
  append initrd=initrd.img inst.stage2=hd:LABEL=CentOS-9-x86_64-dvd inst.ks=cdrom:/ks.cfg quiet

label rescue
  menu label ^Rescue installed system
  kernel vmlinuz
  append initrd=initrd.img inst.stage2=hd:LABEL=CentOS-9-x86_64-dvd rescue quiet

label local
  menu label Boot from ^local drive
  localboot 0xffff

label memtest86
  menu label Test ^memory
  kernel memtest
  append -
EOF

# 创建自动安装的Kickstart文件
cat > "$ISO_CONTENT/ks.cfg" << 'EOF'
#version=RHEL9
# System authorization information
auth --enableshadow --passalgo=sha512

# Use network installation
url --url="cdrom"

# Use text mode install
text

# Keyboard layouts
keyboard --vckeymap=us --xlayouts='us'

# System language
lang en_US.UTF-8

# Network information
network --bootproto=dhcp --device=eth0 --onboot=off --ipv6=auto

# Root password (默认密码: hpcadmin)
rootpw --iscrypted $6$random_salt$hashed_password

# System services
services --disabled="postfix" --enabled="chronyd,sshd,NetworkManager"

# System timezone
timezone Asia/Shanghai --isUtc

# System bootloader configuration
bootloader --location=mbr --boot-drive=sda

# Clear the Master Boot Record
zerombr

# Partition clearing information
clearpart --all --initlabel

# Disk partitioning information
part /boot --fstype="xfs" --ondisk=sda --size=1024
part / --fstype="xfs" --ondisk=sda --grow --size=1
part swap --fstype="swap" --ondisk=sda --size=8192

# Reboot after installation
reboot

# SELinux configuration
selinux --disabled

# Firewall configuration
firewall --disabled

# System authorization information
authconfig --enableshadow --passalgo=sha512

# Package selection
%packages
@^minimal-environment
@core
@development
chrony
wget
curl
lscpu
htop
iotop
perf
openmpi
gcc
gcc-c++
gcc-gfortran
%end

# Post-installation script
%post
# 执行自定义配置脚本
/bin/bash /run/install/repo/custom/post-install.sh
%end
EOF

# 卸载原始ISO
umount "$MOUNT_POINT"

# 创建新的ISO镜像
echo "Creating custom ISO image..."
genisoimage -U -r -v -T -J -joliet-long \
  -V "CentOS-9-x86_64-HPC" \
  -volset "CentOS-9-x86_64-HPC" \
  -A "CentOS-9-x86_64-HPC" \
  -b isolinux/isolinux.bin \
  -c isolinux/boot.cat \
  -no-emul-boot \
  -boot-load-size 4 \
  -boot-info-table \
  -eltorito-alt-boot \
  -e images/efiboot.img \
  -no-emul-boot \
  -o "$ISO_TARGET" \
  "$ISO_CONTENT"

# 设置正确的文件权限
implantisomd5 "$ISO_TARGET"
isohybrid --uefi "$ISO_TARGET"

echo "Custom ISO image created: $ISO_TARGET"
echo "Size: $(du -h "$ISO_TARGET" | cut -f1)"
```

#### 基于容器的镜像构建

**使用Packer构建镜像**
```json
{
  "builders": [
    {
      "type": "qemu",
      "iso_url": "CentOS-9-x86_64-dvd.iso",
      "iso_checksum": "sha256:abc123...",
      "output_directory": "output-centos9-hpc",
      "vm_name": "centos9-hpc",
      "disk_size": 40960,
      "format": "qcow2",
      "headless": false,
      "accelerator": "kvm",
      "cpus": 4,
      "memory": 4096,
      "boot_wait": "10s",
      "boot_command": [
        "<tab> text inst.ks=http://{{ .HTTPIP }}:{{ .HTTPPort }}/ks.cfg<enter><wait>"
      ]
    }
  ],
  "provisioners": [
    {
      "type": "file",
      "source": "ks.cfg",
      "destination": "/tmp/ks.cfg"
    },
    {
      "type": "shell",
      "inline": [
        "dnf update -y",
        "dnf install -y openmpi gcc gcc-c++ gcc-gfortran",
        "dnf install -y htop iotop perf chrony",
        "systemctl enable chronyd",
        "echo 'net.core.somaxconn = 65535' >> /etc/sysctl.conf",
        "echo 'vm.swappiness = 1' >> /etc/sysctl.conf",
        "sysctl -p"
      ]
    }
  ]
}
```

### 镜像分发与部署

#### 网络分发策略

**多服务器镜像分发**
```bash
#!/bin/bash
# distribute-image.sh

# 配置变量
IMAGE_FILE="custom-centos9-hpc.iso"
DIST_SERVERS=("192.168.1.20" "192.168.1.21" "192.168.1.22")
DIST_PATH="/var/www/html/install"

# 分发镜像到各个分发服务器
for server in "${DIST_SERVERS[@]}"; do
    echo "Distributing image to $server..."
    scp "$IMAGE_FILE" "root@$server:$DIST_PATH/"
    ssh "root@$server" "chmod 644 $DIST_PATH/$IMAGE_FILE"
    echo "Image distributed to $server"
done

# 配置负载均衡
cat > /etc/haproxy/haproxy.cfg << 'EOF'
global
    log /dev/log local0
    chroot /var/lib/haproxy
    stats socket /run/haproxy/admin.sock mode 660 level admin
    stats timeout 30s
    user haproxy
    group haproxy
    daemon

defaults
    mode http
    log global
    option httplog
    option dontlognull
    timeout connect 5000
    timeout client 50000
    timeout server 50000

frontend install_frontend
    bind *:80
    default_backend install_backend

backend install_backend
    balance roundrobin
    server dist1 192.168.1.20:80 check
    server dist2 192.168.1.21:80 check
    server dist3 192.168.1.22:80 check
EOF

systemctl restart haproxy
```

#### 部署验证

**自动化部署验证脚本**
```bash
#!/bin/bash
# validate-deployment.sh

# 验证脚本
validate_node() {
    local node=$1
    echo "Validating $node..."

    # 检查系统版本
    ssh "$node" "cat /etc/redhat-release"

    # 检查内核参数
    ssh "$node" "sysctl net.core.somaxconn"
    ssh "$node" "sysctl vm.swappiness"

    # 检查安装的软件包
    ssh "$node" "rpm -q openmpi gcc htop iotop"

    # 检查服务状态
    ssh "$node" "systemctl is-active chronyd"
    ssh "$node" "systemctl is-active sshd"

    # 检查网络配置
    ssh "$node" "ip addr show | grep inet"
    ssh "$node" "ping -c 3 8.8.8.8"

    # 检查时间同步
    ssh "$node" "chronyc sources -v"

    echo "$node validation completed"
}

# 验证所有计算节点
for i in {1..10}; do
    node="compute-$(printf "%03d" $i)"
    validate_node "$node" &
done

# 等待所有验证完成
wait

echo "All validations completed!"
```

## 本章小结

操作系统部署是HPC集群建设的关键环节。本章详细介绍了：

1. **批量安装系统**：PXE网络安装环境搭建、Kickstart自动化安装、系统镜像制作
2. **配置管理工具**：Ansible、Puppet、Chef的使用和配置
3. **系统镜像制作**：定制化系统镜像创建、容器化构建、镜像分发策略

通过本章学习，读者能够：
- 搭建高效的批量安装环境
- 使用配置管理工具实现自动化部署
- 制作符合HPC需求的定制化系统镜像
- 建立完善的部署验证机制

掌握这些技能将大大提高HPC集群的部署效率和系统一致性，为后续的运维管理工作奠定坚实基础。