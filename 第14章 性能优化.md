# ç¬¬14ç«  æ€§èƒ½ä¼˜åŒ–

> HPCé›†ç¾¤æ€§èƒ½åˆ†æä¸ä¼˜åŒ–å®æˆ˜æŒ‡å—

## ğŸš€ æœ¬ç« æ¦‚è¿°

æ€§èƒ½ä¼˜åŒ–æ˜¯HPCè¿ç»´çš„æ ¸å¿ƒç›®æ ‡ã€‚æœ¬ç« å°†æ·±å…¥ä»‹ç»HPCé›†ç¾¤çš„æ€§èƒ½åˆ†ææ–¹æ³•ã€ç“¶é¢ˆè¯†åˆ«æŠ€æœ¯ã€ä¼˜åŒ–ç­–ç•¥åˆ¶å®šå’Œæ€§èƒ½åŸºå‡†æµ‹è¯•ï¼Œå¸®åŠ©ä½ æœ€å¤§åŒ–é›†ç¾¤çš„è®¡ç®—æ•ˆç‡å’Œèµ„æºåˆ©ç”¨ç‡ã€‚

**å­¦ä¹ ç›®æ ‡ï¼š**
- æŒæ¡ä¸»æµæ€§èƒ½åˆ†æå·¥å…·çš„ä½¿ç”¨æ–¹æ³•
- å­¦ä¼šç³»ç»ŸåŒ–çš„ç“¶é¢ˆè¯†åˆ«å’Œåˆ†ææŠ€æœ¯
- åˆ¶å®šæœ‰æ•ˆçš„æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
- å»ºç«‹å®Œæ•´çš„æ€§èƒ½åŸºå‡†æµ‹è¯•ä½“ç³»

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–æ¡†æ¶

### 14.1 æ€§èƒ½åˆ†æå·¥å…·

#### 14.1.1 ç³»ç»Ÿçº§æ€§èƒ½åˆ†æå·¥å…·

**top/htop - å®æ—¶ç³»ç»Ÿç›‘æ§**

```bash
# åŸºæœ¬ä½¿ç”¨
top                    # æ˜¾ç¤ºç³»ç»Ÿæ•´ä½“çŠ¶æ€
top -p 1234,5678       # ç›‘æ§ç‰¹å®šè¿›ç¨‹
top -u username        # ç›‘æ§ç‰¹å®šç”¨æˆ·è¿›ç¨‹
top -d 2               # è®¾ç½®åˆ·æ–°é—´éš”ä¸º2ç§’

# htopé«˜çº§åŠŸèƒ½
htop                   # å½©è‰²ç•Œé¢ï¼Œæ›´ç›´è§‚
# åœ¨htopç•Œé¢ä¸­ï¼š
# F5: æ ‘çŠ¶è§†å›¾
# F6: æ’åºæ–¹å¼
# F9: å‘é€ä¿¡å·
# F3: æœç´¢è¿›ç¨‹
```

**vmstat - ç³»ç»Ÿæ€§èƒ½ç»Ÿè®¡**

```bash
# åŸºæœ¬ä½¿ç”¨
vmstat 2               # æ¯2ç§’æ˜¾ç¤ºä¸€æ¬¡ç»Ÿè®¡
vmstat 2 10            # æ¯2ç§’æ˜¾ç¤ºä¸€æ¬¡ï¼Œå…±æ˜¾ç¤º10æ¬¡

# è¯¦ç»†å‚æ•°è¯´æ˜
vmstat -a              # æ˜¾ç¤ºæ´»è·ƒå’Œéæ´»è·ƒå†…å­˜
vmstat -d              # æ˜¾ç¤ºç£ç›˜ç»Ÿè®¡
vmstat -s              # æ˜¾ç¤ºäº‹ä»¶è®¡æ•°å™¨

# æ€§èƒ½åˆ†æè„šæœ¬
#!/bin/bash
# /opt/performance/vmstat_monitor.sh

INTERVAL=${1:-5}
DURATION=${2:-300}  # é»˜è®¤5åˆ†é’Ÿ

echo "=== VMSTAT Performance Monitor ==="
echo "Interval: ${INTERVAL}s, Duration: ${DURATION}s"
echo "Timestamp,CPU_us,CPU_sy,CPU_id,CPU_wa,CPU_st,Mem_free,Mem_buff,Mem_cache,Swap_in,Swap_out,IO_bi,IO_bo,Processes_running,Processes_blocked"

end_time=$(($(date +%s) + DURATION))

while [ $(date +%s) -lt $end_time ]; do
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    vmstat_output=$(vmstat $INTERVAL 1 | tail -1)
    echo "$timestamp,$vmstat_output"
    sleep $INTERVAL
done
```

**iostat - I/Oæ€§èƒ½åˆ†æ**

```bash
# åŸºæœ¬ä½¿ç”¨
iostat -x 2            # æ¯2ç§’æ˜¾ç¤ºæ‰©å±•ç»Ÿè®¡
iostat -x -d sda 2     # ç›‘æ§ç‰¹å®šè®¾å¤‡

# å…³é”®æŒ‡æ ‡è§£é‡Š
# %util: è®¾å¤‡åˆ©ç”¨ç‡ï¼Œæ¥è¿‘100%è¡¨ç¤ºI/Oç“¶é¢ˆ
# await: å¹³å‡ç­‰å¾…æ—¶é—´ï¼ŒåŒ…æ‹¬é˜Ÿåˆ—ç­‰å¾…å’Œå¤„ç†æ—¶é—´
# svctm: å¹³å‡æœåŠ¡æ—¶é—´
# rrqm/s, wrqm/s: æ¯ç§’åˆå¹¶çš„è¯»/å†™è¯·æ±‚æ•°

# I/Oæ€§èƒ½ç›‘æ§è„šæœ¬
#!/bin/bash
# /opt/performance/io_monitor.sh

DEVICE=${1:-sda}
INTERVAL=${2:-5}

echo "=== I/O Performance Monitor ==="
echo "Device: $DEVICE, Interval: ${INTERVAL}s"
echo "Time,Device,r/s,w/s,rMB/s,wMB/s,rrqm/s,wrqm/s,rareq-sz,wareq-sz,await,r_await,w_await,util"

while true; do
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    iostat_output=$(iostat -x $DEVICE 1 1 | grep "$DEVICE" | awk '{print "'$timestamp'",$1,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15}')
    echo "$iostat_output"
    sleep $INTERVAL
done
```

**sar - ç³»ç»Ÿæ´»åŠ¨æŠ¥å‘Š**

```bash
# å®‰è£…sysstat
yum install sysstat

# CPUä½¿ç”¨ç‡ç»Ÿè®¡
sar -u 2 10            # æ¯2ç§’é‡‡æ ·ï¼Œå…±10æ¬¡

# å†…å­˜ä½¿ç”¨ç»Ÿè®¡
sar -r 2 10            # å†…å­˜ä½¿ç”¨æƒ…å†µ

# ç½‘ç»œç»Ÿè®¡
sar -n DEV 2 10        # ç½‘ç»œæ¥å£ç»Ÿè®¡

# ç£ç›˜ç»Ÿè®¡
sar -d 2 10            # ç£ç›˜I/Oç»Ÿè®¡

# ç”Ÿæˆå†å²æŠ¥å‘Š
sar -u -f /var/log/sa/sa$(date +%d)
```

#### 14.1.2 è¿›ç¨‹çº§æ€§èƒ½åˆ†æå·¥å…·

**perf - Linuxæ€§èƒ½åˆ†æå·¥å…·**

```bash
# å®‰è£…perf
yum install perf

# CPUæ€§èƒ½åˆ†æ
perf top                   # å®æ—¶CPUä½¿ç”¨åˆ†æ
perf record -a sleep 10    # è®°å½•10ç§’çš„æ€§èƒ½æ•°æ®
perf report               # ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š

# å‡½æ•°çº§åˆ†æ
perf record -g ./my_program    # è®°å½•ç¨‹åºæ‰§è¡Œ
perf report -g            # æ˜¾ç¤ºè°ƒç”¨å›¾

# ç¡¬ä»¶äº‹ä»¶ç›‘æ§
perf stat ./my_program    # ç»Ÿè®¡ç¡¬ä»¶äº‹ä»¶
perf stat -e cycles,instructions,cache-misses ./my_program

# å†…å­˜è®¿é—®åˆ†æ
perf mem record ./my_program    # å†…å­˜è®¿é—®æ¨¡å¼åˆ†æ
perf mem report           # å†…å­˜è®¿é—®æŠ¥å‘Š
```

**strace - ç³»ç»Ÿè°ƒç”¨è·Ÿè¸ª**

```bash
# åŸºæœ¬ä½¿ç”¨
strace ./my_program       # è·Ÿè¸ªç¨‹åºçš„ç³»ç»Ÿè°ƒç”¨
strace -p 1234           # è·Ÿè¸ªè¿è¡Œä¸­çš„è¿›ç¨‹
strace -c ./my_program   # ç»Ÿè®¡ç³»ç»Ÿè°ƒç”¨

# è¿‡æ»¤ç‰¹å®šè°ƒç”¨
strace -e trace=open,read,write ./my_program
strace -e trace=!rt_sigreturn ./my_program

# è¾“å‡ºåˆ°æ–‡ä»¶
strace -o trace.log ./my_program
```

**ltrace - åº“å‡½æ•°è°ƒç”¨è·Ÿè¸ª**

```bash
# å®‰è£…ltrace
yum install ltrace

# åŸºæœ¬ä½¿ç”¨
ltrace ./my_program       # è·Ÿè¸ªåº“å‡½æ•°è°ƒç”¨
ltrace -c ./my_program    # ç»Ÿè®¡åº“å‡½æ•°è°ƒç”¨

# è¿‡æ»¤ç‰¹å®šå‡½æ•°
ltrace -e malloc,free ./my_program
```

#### 14.1.3 ç½‘ç»œæ€§èƒ½åˆ†æå·¥å…·

**netstat/ss - ç½‘ç»œè¿æ¥åˆ†æ**

```bash
# è¿æ¥çŠ¶æ€ç»Ÿè®¡
ss -tuln                 # æ˜¾ç¤ºæ‰€æœ‰ç›‘å¬ç«¯å£
ss -s                    # ç»Ÿè®¡è¿æ¥æ•°
ss -p                    # æ˜¾ç¤ºè¿›ç¨‹ä¿¡æ¯

# ç½‘ç»œæ€§èƒ½ç›‘æ§
ss -i                    # æ˜¾ç¤ºæ¥å£ç»Ÿè®¡
ss -ti                   # TCPè¿æ¥è¯¦ç»†ä¿¡æ¯

# ç½‘ç»œè¿æ¥ç›‘æ§è„šæœ¬
#!/bin/bash
# /opt/performance/network_monitor.sh

INTERVAL=${1:-5}

echo "=== Network Connection Monitor ==="
echo "Interval: ${INTERVAL}s"
echo "Time,Total_Connections,ESTABLISHED,TIME_WAIT,CLOSE_WAIT,LISTEN"

while true; do
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    total=$(ss -t | wc -l)
    established=$(ss -t | grep ESTAB | wc -l)
    time_wait=$(ss -t | grep TIME-WAIT | wc -l)
    close_wait=$(ss -t | grep CLOSE-WAIT | wc -l)
    listen=$(ss -t | grep LISTEN | wc -l)

    echo "$timestamp,$total,$established,$time_wait,$close_wait,$listen"
    sleep $INTERVAL
done
```

**iftop - ç½‘ç»œå¸¦å®½ç›‘æ§**

```bash
# å®‰è£…iftop
yum install iftop

# åŸºæœ¬ä½¿ç”¨
iftop                    # æ˜¾ç¤ºå®æ—¶ç½‘ç»œæµé‡
iftop -i eth0           # æŒ‡å®šç½‘ç»œæ¥å£
iftop -B                # ä»¥å­—èŠ‚æ˜¾ç¤º
iftop -n                # ä¸è§£æä¸»æœºå

# å‘½ä»¤è¡Œé€‰é¡¹
# P: æ˜¾ç¤ºç«¯å£
# b: æ˜¾ç¤ºæµé‡å›¾
# t: æ–‡æœ¬æ¨¡å¼æ˜¾ç¤º
# L: è®¾ç½®æ˜¾ç¤ºè¡Œæ•°
```

**iperf3 - ç½‘ç»œå¸¦å®½æµ‹è¯•**

```bash
# å®‰è£…iperf3
yum install iperf3

# æœåŠ¡ç«¯
iperf3 -s                # å¯åŠ¨æœåŠ¡ç«¯

# å®¢æˆ·ç«¯æµ‹è¯•
iperf3 -c server_ip      # åŸºæœ¬æµ‹è¯•
iperf3 -c server_ip -t 60 # æµ‹è¯•60ç§’
iperf3 -c server_ip -P 4 # ä½¿ç”¨4ä¸ªå¹¶è¡Œè¿æ¥
iperf3 -c server_ip -i 1 # æ¯ç§’æŠ¥å‘Šä¸€æ¬¡

# UDPæµ‹è¯•
iperf3 -c server_ip -u   # UDPæ¨¡å¼
iperf3 -c server_ip -u -b 100M # è®¾ç½®å¸¦å®½
```

#### 14.1.4 HPCä¸“ç”¨æ€§èƒ½å·¥å…·

**SLURMæ€§èƒ½ç›‘æ§**

```bash
# ä½œä¸šæ€§èƒ½åˆ†æ
sacct -j job_id --format=JobID,JobName,State,AllocCPUS,Elapsed,TotalCPU,MaxRSS,AveRSS

# é˜Ÿåˆ—æ€§èƒ½ç»Ÿè®¡
squeue -o "%j %u %T %M %l %C" | head -20

# èŠ‚ç‚¹åˆ©ç”¨ç‡åˆ†æ
scontrol show nodes | grep -E "NodeName|CPUAlloc|CPULoad|RealMemory"

# SLURMæ€§èƒ½ç›‘æ§è„šæœ¬
#!/bin/bash
# /opt/performance/slurm_monitor.sh

INTERVAL=${1:-30}

echo "=== SLURM Performance Monitor ==="
echo "Interval: ${INTERVAL}s"
echo "Time,Total_Jobs,Running_Jobs,Pending_Jobs,Queued_Time,Avg_CPU_Usage,Memory_Utilization"

while true; do
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # ä½œä¸šç»Ÿè®¡
    total_jobs=$(squeue | wc -l)
    running_jobs=$(squeue -t RUNNING | wc -l)
    pending_jobs=$(squeue -t PENDING | wc -l)

    # é˜Ÿåˆ—æ—¶é—´ç»Ÿè®¡
    if [ $pending_jobs -gt 0 ]; then
        avg_queue_time=$(squeue -t PENDING -o "%M" | tail -n +2 | awk '{sum+=$1; count++} END {print sum/count}')
    else
        avg_queue_time=0
    fi

    # CPUå’Œå†…å­˜ä½¿ç”¨ç‡
    scontrol show nodes | grep -E "CPULoad|RealMemory|AllocMem" > /tmp/node_stats
    cpu_usage=$(grep "CPULoad" /tmp/node_stats | awk '{sum+=$2; count++} END {print sum/count}')
    mem_total=$(grep "RealMemory" /tmp/node_stats | awk '{sum+=$2; count++} END {print sum}')
    mem_used=$(grep "AllocMem" /tmp/node_stats | awk '{sum+=$2; count++} END {print sum}')
    mem_util=$(echo "scale=2; $mem_used * 100 / $mem_total" | bc)

    echo "$timestamp,$total_jobs,$running_jobs,$pending_jobs,$avg_queue_time,$cpu_usage,$mem_util"
    sleep $INTERVAL
done
```

**MPIæ€§èƒ½åˆ†æå·¥å…·**

```bash
# ä½¿ç”¨Intel VTuneè¿›è¡ŒMPIåˆ†æ
module load intel-vtune
vtune -collect hotspots mpirun ./my_mpi_program
vtune -report hotspots -result-dir ./result

# ä½¿ç”¨TAUè¿›è¡Œæ€§èƒ½åˆ†æ
module load tau
tau_select_file my_program
tau_exec -ebs ./my_mpi_program

# ä½¿ç”¨HPCToolkit
module load hpctoolkit
hpcrun -o my_program.hpcrun mpirun ./my_program
hpcprof -o my_program.hpcprof my_program.hpcrun
```

### 14.2 ç“¶é¢ˆè¯†åˆ«æ–¹æ³•

#### 14.2.1 CPUç“¶é¢ˆè¯†åˆ«

**CPUä½¿ç”¨ç‡åˆ†æ**

```bash
#!/bin/bash
# /opt/performance/cpu_bottleneck.sh

echo "=== CPU Bottleneck Analysis ==="
echo "Timestamp,Avg_CPU_Usage,Max_CPU_Usage,Load_Avg_1m,Load_Avg_5m,Load_Avg_15m,Context_Switches,Process_Count"

# æ”¶é›†CPUæŒ‡æ ‡
while true; do
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # CPUä½¿ç”¨ç‡
    cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print 100 - $8}' | sed 's/%id,//')
    max_cpu=$(ps aux | awk 'NR>1 {print $3}' | sort -nr | head -1)

    # è´Ÿè½½å¹³å‡å€¼
    load_avg=$(uptime | awk -F'load average:' '{print $2}' | sed 's/ //g')

    # ä¸Šä¸‹æ–‡åˆ‡æ¢å’Œè¿›ç¨‹æ•°
    context_switches=$(vmstat 1 1 | tail -1 | awk '{print $12}')
    process_count=$(ps aux | wc -l)

    echo "$timestamp,$cpu_usage,$max_cpu,$load_avg,$context_switches,$process_count"
    sleep 10
done
```

**CPUç¼“å­˜æœªå‘½ä¸­åˆ†æ**

```bash
#!/bin/bash
# /opt/performance/cpu_cache_analysis.sh

echo "=== CPU Cache Analysis ==="
echo "Collecting cache performance data..."

# ä½¿ç”¨perfæ”¶é›†ç¼“å­˜æœªå‘½ä¸­æ•°æ®
perf stat -e cache-misses,cache-references,instructions,cycles ./my_program

# åˆ†æç¼“å­˜å‘½ä¸­ç‡
cache_misses=$(perf stat -e cache-misses ./my_program 2>&1 | grep "cache-misses" | awk '{print $1}')
cache_references=$(perf stat -e cache-references ./my_program 2>&1 | grep "cache-references" | awk '{print $1}')

if [ ! -z "$cache_misses" ] && [ ! -z "$cache_references" ]; then
    cache_miss_rate=$(echo "scale=2; $cache_misses * 100 / $cache_references" | bc)
    echo "Cache Miss Rate: $cache_miss_rate%"
fi
```

#### 14.2.2 å†…å­˜ç“¶é¢ˆè¯†åˆ«

**å†…å­˜ä½¿ç”¨åˆ†æ**

```bash
#!/bin/bash
# /opt/performance/memory_bottleneck.sh

echo "=== Memory Bottleneck Analysis ==="
echo "Timestamp,Memory_Usage%,Swap_Usage%,Page_Faults,Page_In,Page_Out,Buffers,Cached"

while true; do
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # å†…å­˜ä½¿ç”¨ç‡
    mem_info=$(free -m | awk 'NR==2{printf "%.2f", $3*100/$2}')
    swap_info=$(free -m | awk 'NR==3{printf "%.2f", $3*100/$2}')

    # é¡µé¢é”™è¯¯ç»Ÿè®¡
    page_faults=$(vmstat | tail -1 | awk '{print $10}')
    page_in=$(vmstat | tail -1 | awk '{print $6}')
    page_out=$(vmstat | tail -1 | awk '{print $7}')

    # ç¼“å†²åŒºå’Œç¼“å­˜
    buffers=$(free -m | awk 'NR==2{print $6}')
    cached=$(free -m | awk 'NR==2{print $7}')

    echo "$timestamp,$mem_info,$swap_info,$page_faults,$page_in,$page_out,$buffers,$cached"
    sleep 10
done
```

**å†…å­˜æ³„æ¼æ£€æµ‹**

```bash
#!/bin/bash
# /opt/performance/memory_leak_detection.sh

PROGRAM=$1
TEST_DURATION=${2:-600}  # é»˜è®¤10åˆ†é’Ÿ

if [ -z "$PROGRAM" ]; then
    echo "Usage: $0 <program> [test_duration_seconds]"
    exit 1
fi

echo "=== Memory Leak Detection for $PROGRAM ==="
echo "Duration: ${TEST_DURATION}s"
echo "Time,PID,VSZ(KB),RSS(KB),Memory_Growth"

start_time=$(date +%s)
end_time=$((start_time + TEST_DURATION))

# å¯åŠ¨ç¨‹åº
$PROGRAM &
PROGRAM_PID=$!
sleep 5

# è®°å½•åˆå§‹å†…å­˜ä½¿ç”¨
initial_rss=$(ps -p $PROGRAM_PID -o rss=)
echo "Initial RSS: ${initial_rss}KB"

# ç›‘æ§å†…å­˜ä½¿ç”¨
while [ $(date +%s) -lt $end_time ]; do
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    if kill -0 $PROGRAM_PID 2>/dev/null; then
        # è·å–å†…å­˜ä½¿ç”¨
        vsz=$(ps -p $PROGRAM_PID -o vsz=)
        rss=$(ps -p $PROGRAM_PID -o rss=)

        # è®¡ç®—å†…å­˜å¢é•¿
        memory_growth=$((rss - initial_rss))

        echo "$timestamp,$PROGRAM_PID,$vsz,$rss,$memory_growth"
        sleep 30
    else
        echo "Program terminated"
        break
    fi
done

# åœæ­¢ç¨‹åº
kill $PROGRAM_PID 2>/dev/null

# åˆ†æç»“æœ
final_rss=$(ps -p $PROGRAM_PID -o rss= 2>/dev/null || echo "0")
total_growth=$((final_rss - initial_rss))

echo ""
echo "=== Analysis Result ==="
echo "Initial RSS: ${initial_rss}KB"
echo "Final RSS: ${final_rss}KB"
echo "Total Growth: ${total_growth}KB"

if [ $total_growth -gt 10000 ]; then  # è¶…è¿‡10MB
    echo "âš ï¸ Potential memory leak detected!"
else
    echo "âœ“ No significant memory leak detected"
fi
```

#### 14.2.3 I/Oç“¶é¢ˆè¯†åˆ«

**ç£ç›˜I/Oåˆ†æ**

```bash
#!/bin/bash
# /opt/performance/io_bottleneck.sh

echo "=== I/O Bottleneck Analysis ==="
echo "Device,r/s,w/s,rMB/s,wMB/s,await,r_await,w_await,%util,avg_queue"

# ç›‘æ§æ‰€æœ‰ç£ç›˜è®¾å¤‡
devices=$(lsblk -d -n -o NAME,TYPE | grep disk | awk '{print $1}')

for device in $devices; do
    echo "--- Device: $device ---"
    iostat -x $device 1 5 | tail -5
done
```

**æ–‡ä»¶ç³»ç»Ÿæ€§èƒ½åˆ†æ**

```bash
#!/bin/bash
# /opt/performance/filesystem_analysis.sh

echo "=== Filesystem Performance Analysis ==="

# æ£€æŸ¥æ–‡ä»¶ç³»ç»Ÿç±»å‹
mount | grep -E "ext4|xfs|lustre|gpfs" | while read line; do
    echo "Filesystem: $line"
done

# æ£€æŸ¥Inodeä½¿ç”¨æƒ…å†µ
df -i

# æ£€æŸ¥å¤§æ–‡ä»¶å’Œç›®å½•
echo "Large files (>1GB):"
find / -type f -size +1G 2>/dev/null | head -10

echo "Large directories:"
du -sh /* 2>/dev/null | sort -hr | head -10

# LUSTREç‰¹å®šåˆ†æ
if mount | grep -q lustre; then
    echo "=== LUSTRE Analysis ==="
    lfs df -h
    lfs getstripe /scratch
    lctl get_param osc.*.stats
fi
```

#### 14.2.4 ç½‘ç»œç“¶é¢ˆè¯†åˆ«

**ç½‘ç»œå»¶è¿Ÿåˆ†æ**

```bash
#!/bin/bash
# /opt/performance/network_latency_analysis.sh

TARGET_NODES="compute-node-{01..10}"
INTERVAL=${1:-10}

echo "=== Network Latency Analysis ==="
echo "Target,Avg_Latency(ms),Max_Latency(ms),Packet_Loss(%),Jitter(ms)"

for node in $TARGET_NODES; do
    if ping -c 10 -W 1 $node &>/dev/null; then
        # æ‰§è¡Œpingæµ‹è¯•
        ping_result=$(ping -c 10 -W 1 $node)

        # æå–ç»Ÿè®¡ä¿¡æ¯
        avg_latency=$(echo "$ping_result" | grep "avg" | awk -F'/' '{print $5}')
        max_latency=$(echo "$ping_result" | grep "avg" | awk -F'/' '{print $7}')
        packet_loss=$(echo "$ping_result" | grep "packet loss" | awk '{print $6}' | sed 's/%//')

        if [ ! -z "$avg_latency" ]; then
            # è®¡ç®—æŠ–åŠ¨ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
            jitter=$(echo "scale=2; $max_latency - $avg_latency" | bc)
            echo "$node,$avg_latency,$max_latency,$packet_loss,$jitter"
        else
            echo "$node,FAILED,FAILED,100,FAILED"
        fi
    else
        echo "$node,UNREACHABLE,UNREACHABLE,100,UNREACHABLE"
    fi
done
```

**ç½‘ç»œå¸¦å®½ç“¶é¢ˆåˆ†æ**

```bash
#!/bin/bash
# /opt/performance/network_bandwidth_analysis.sh

TARGET_HOST=$1
TEST_DURATION=${2:-60}

if [ -z "$TARGET_HOST" ]; then
    echo "Usage: $0 <target_host> [test_duration_seconds]"
    exit 1
fi

echo "=== Network Bandwidth Analysis ==="
echo "Target: $TARGET_HOST"
echo "Duration: ${TEST_DURATION}s"

# TCPå¸¦å®½æµ‹è¯•
echo "TCP Bandwidth Test:"
iperf3 -c $TARGET_HOST -t $TEST_DURATION -f M

# UDPå¸¦å®½æµ‹è¯•
echo ""
echo "UDP Bandwidth Test:"
iperf3 -c $TARGET_HOST -u -b 1G -t $TEST_DURATION -f M

# å¤šè¿æ¥æµ‹è¯•
echo ""
echo "Multi-Connection Test (4 parallel):"
iperf3 -c $TARGET_HOST -P 4 -t $TEST_DURATION -f M
```

### 14.3 ä¼˜åŒ–ç­–ç•¥åˆ¶å®š

#### 14.3.1 CPUä¼˜åŒ–ç­–ç•¥

**CPUäº²å’Œæ€§ä¼˜åŒ–**

```bash
#!/bin/bash
# /opt/performance/cpu_optimization.sh

echo "=== CPU Optimization ==="

# æŸ¥çœ‹CPUæ‹“æ‰‘
echo "CPU Topology:"
lscpu | grep -E "Socket|Core|Thread|NUMA"

# è®¾ç½®è¿›ç¨‹CPUäº²å’Œæ€§
PROGRAM=$1
if [ ! -z "$PROGRAM" ]; then
    # å¯åŠ¨ç¨‹åºå¹¶ç»‘å®šåˆ°ç‰¹å®šCPU
    taskset -c 0-7 $PROGRAM &  # ç»‘å®šåˆ°CPU 0-7
    echo "Program started with CPU affinity: 0-7"
fi

# NUMAä¼˜åŒ–
echo ""
echo "NUMA Topology:"
numactl --hardware

# NUMAæ„ŸçŸ¥çš„å†…å­˜åˆ†é…
echo ""
echo "NUMA-aware allocation example:"
echo "numactl --membind=0 --cpunodebind=0 ./my_program"
```

**CPUé¢‘ç‡è°ƒèŠ‚**

```bash
#!/bin/bash
# /opt/performance/cpu_frequency_optimization.sh

echo "=== CPU Frequency Optimization ==="

# æŸ¥çœ‹å½“å‰é¢‘ç‡è°ƒèŠ‚å™¨
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor

# æŸ¥çœ‹å¯ç”¨çš„è°ƒèŠ‚å™¨
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors

# è®¾ç½®é«˜æ€§èƒ½æ¨¡å¼
echo performance | tee /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor

# æŸ¥çœ‹å½“å‰é¢‘ç‡
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq

# æŸ¥çœ‹æœ€å¤§é¢‘ç‡
cat /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq

# è®¾ç½®å›ºå®šé¢‘ç‡ï¼ˆå¦‚æœæ”¯æŒï¼‰
# echo 2500000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed
```

#### 14.3.2 å†…å­˜ä¼˜åŒ–ç­–ç•¥

**å†…å­˜åˆ†é…ä¼˜åŒ–**

```bash
#!/bin/bash
# /opt/performance/memory_optimization.sh

echo "=== Memory Optimization ==="

# æŸ¥çœ‹å†…å­˜é…ç½®
echo "Memory Configuration:"
free -h
cat /proc/meminfo | grep -E "MemTotal|MemFree|MemAvailable|Buffers|Cached"

# NUMAå†…å­˜ä¼˜åŒ–
echo ""
echo "NUMA Memory Configuration:"
numactl --hardware

# å†…å­˜åˆ†é…ç­–ç•¥ç¤ºä¾‹
echo ""
echo "Memory allocation strategies:"
echo "1. ä½¿ç”¨numactlè¿›è¡ŒNUMAæ„ŸçŸ¥åˆ†é…"
echo "   numactl --membind=0,1 --cpunodebind=0,1 ./my_program"
echo ""
echo "2. è®¾ç½®å¤§é¡µå†…å­˜"
echo "   echo 1024 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages"
echo "   mount -t hugetlbfs none /dev/hugepages"
echo ""
echo "3. è°ƒæ•´å†…å­˜å›æ”¶ç­–ç•¥"
echo "   echo 1 > /proc/sys/vm/overcommit_memory"
echo "   echo 50 > /proc/sys/vm/swappiness"

# å¤§é¡µå†…å­˜é…ç½®
echo ""
echo "Hugepages Configuration:"
grep -i huge /proc/meminfo
```

**å†…å­˜è®¿é—®æ¨¡å¼ä¼˜åŒ–**

```bash
#!/bin/bash
# /opt/performance/memory_access_optimization.sh

echo "=== Memory Access Pattern Optimization ==="

# ä½¿ç”¨perfåˆ†æå†…å­˜è®¿é—®
echo "Analyzing memory access patterns..."
perf record -e mem-loads,mem-stores ./my_program
perf report -s symbol,dso

# ç¼“å­˜å‹å¥½çš„ä»£ç ç¤ºä¾‹
cat << 'EOF'
// ç¼“å­˜å‹å¥½çš„å¾ªç¯é¡ºåº
for (int i = 0; i < N; i++) {
    for (int j = 0; j < M; j++) {
        // è®¿é—® a[i][j] - é¡ºåºè®¿é—®
    }
}

// é¿å…çš„æ¨¡å¼
for (int j = 0; j < M; j++) {
    for (int i = 0; i < N; i++) {
        // è®¿é—® a[i][j] - è·³è·ƒè®¿é—®
    }
}
EOF
```

#### 14.3.3 I/Oä¼˜åŒ–ç­–ç•¥

**æ–‡ä»¶ç³»ç»Ÿä¼˜åŒ–**

```bash
#!/bin/bash
# /opt/performance/filesystem_optimization.sh

echo "=== Filesystem Optimization ==="

# ext4ä¼˜åŒ–å‚æ•°
echo "ext4 mount options for performance:"
echo "noatime,nodiratime,data=writeback,barrier=0"

# XFSä¼˜åŒ–å‚æ•°
echo ""
echo "XFS mount options for performance:"
echo "noatime,nodiratime,logbufs=8,logbsize=256k"

# LUSTREä¼˜åŒ–
echo ""
echo "LUSTRE optimization settings:"
echo "lfs setstripe -c -1 /path/to/directory  # ä½¿ç”¨æ‰€æœ‰OST"
echo "lfs setstripe -c 4 /path/to/file        # ä½¿ç”¨4ä¸ªOST"

# æ–‡ä»¶ç³»ç»Ÿæ£€æŸ¥å’Œä¼˜åŒ–
for mount_point in / /home /scratch; do
    if mount | grep -q " $mount_point "; then
        echo ""
        echo "Filesystem info for $mount_point:"
        df -h $mount_point
        mount | grep " $mount_point " | awk '{print $6}'
    fi
done
```

**I/Oè°ƒåº¦å™¨ä¼˜åŒ–**

```bash
#!/bash
# /opt/performance/io_scheduler_optimization.sh

echo "=== I/O Scheduler Optimization ==="

# æŸ¥çœ‹å½“å‰I/Oè°ƒåº¦å™¨
echo "Current I/O schedulers:"
for device in /sys/block/*/queue/scheduler; do
    echo "$(basename $(dirname $device)): $(cat $device)"
done

# è®¾ç½®ä¼˜åŒ–çš„è°ƒåº¦å™¨
echo ""
echo "Recommended schedulers:"
echo "- SSD/NVMe: none or noop"
echo "- HDD: mq-deadline or bfq"

# è®¾ç½®è°ƒåº¦å™¨ç¤ºä¾‹
# echo none > /sys/block/sda/queue/scheduler

# I/Oä¼˜å…ˆçº§è®¾ç½®
echo ""
echo "I/O priority examples:"
echo "ionice -c 1 -n 0 ./my_program  # å®æ—¶ç±»ï¼Œæœ€é«˜ä¼˜å…ˆçº§"
echo "ionice -c 2 -n 0 ./my_program  # å°½åŠ›è€Œä¸ºç±»ï¼Œæœ€é«˜ä¼˜å…ˆçº§"
```

#### 14.3.4 ç½‘ç»œä¼˜åŒ–ç­–ç•¥

**ç½‘ç»œå‚æ•°ä¼˜åŒ–**

```bash
#!/bin/bash
# /opt/performance/network_optimization.sh

echo "=== Network Optimization ==="

# æŸ¥çœ‹å½“å‰ç½‘ç»œå‚æ•°
echo "Current network parameters:"
cat /proc/sys/net/core/rmem_max
cat /proc/sys/net/core/wmem_max
cat /proc/sys/net/ipv4/tcp_rmem
cat /proc/sys/net/ipv4/tcp_wmem

# ç½‘ç»œä¼˜åŒ–è„šæœ¬
cat << 'EOF' > /tmp/network_optimization.sh
#!/bin/bash
# ç½‘ç»œæ€§èƒ½ä¼˜åŒ–è„šæœ¬

# å¢åŠ TCPç¼“å†²åŒºå¤§å°
echo 268435456 > /proc/sys/net/core/rmem_max
echo 268435456 > /proc/sys/net/core/wmem_max
echo 4096 65536 268435456 > /proc/sys/net/ipv4/tcp_rmem
echo 4096 65536 268435456 > /proc/sys/net/ipv4/tcp_wmem

# å¯ç”¨TCPçª—å£ç¼©æ”¾
echo 1 > /proc/sys/net/ipv4/tcp_window_scaling

# ä¼˜åŒ–æ‹¥å¡æ§åˆ¶ç®—æ³•
echo cubic > /proc/sys/net/ipv4/tcp_congestion_control

# å¢åŠ è¿æ¥é˜Ÿåˆ—é•¿åº¦
echo 65536 > /proc/sys/net/core/somaxconn
echo 65536 > /proc/sys/net/core/netdev_max_backlog

# ä¼˜åŒ–InfiniBandå‚æ•°ï¼ˆå¦‚æœé€‚ç”¨ï¼‰
if ibstat &>/dev/null; then
    echo "InfiniBand detected, applying IB optimizations..."
    # è®¾ç½®IB MTU
    echo 4096 > /sys/class/infiniband/*/mtu
fi

echo "Network optimization applied"
EOF

chmod +x /tmp/network_optimization.sh
echo "Run /tmp/network_optimization.sh to apply optimizations"
```

**InfiniBandä¼˜åŒ–**

```bash
#!/bin/bash
# /opt/performance/ib_optimization.sh

echo "=== InfiniBand Optimization ==="

# æ£€æŸ¥InfiniBandçŠ¶æ€
if ! command -v ibstat &> /dev/null; then
    echo "InfiniBand tools not available"
    exit 1
fi

echo "InfiniBand Status:"
ibstat

# æ£€æŸ¥å­ç½‘ç®¡ç†å™¨
echo ""
echo "Subnet Manager Status:"
smpquery -D

# InfiniBandå‚æ•°ä¼˜åŒ–
echo ""
echo "InfiniBand optimization settings:"
cat << 'EOF'
# ç½‘ç»œæ¥å£é…ç½®
echo "Setting IB MTU to 4096..."
echo 4096 > /sys/class/infiniband/*/mtu

# è®¾ç½®QoSå‚æ•°
echo "Optimizing QoS settings..."
echo 15 > /sys/class/infiniband/*/ports/*/pkeys/0

# å¯ç”¨RC transport mode for better performance
echo "Using RC transport mode for MPI..."
EOF

# MPI over InfiniBandä¼˜åŒ–
echo ""
echo "MPI over InfiniBand recommendations:"
echo "- ä½¿ç”¨UCXä¼ è¾“å±‚"
echo "- è®¾ç½®ç¯å¢ƒå˜é‡: UCX_IB_GID_INDEX=0"
echo "- è®¾ç½®ç¯å¢ƒå˜é‡: UCX_TLS=rc,mm"
echo "- ä½¿ç”¨MPIå¤šçº¿ç¨‹æ”¯æŒ"
```

### 14.4 æ€§èƒ½åŸºå‡†æµ‹è¯•

#### 14.4.1 CPUåŸºå‡†æµ‹è¯•

**LINPACKåŸºå‡†æµ‹è¯•**

```bash
#!/bin/bash
# /opt/performance/linpack_benchmark.sh

echo "=== LINPACK Benchmark ==="

# ä¸‹è½½å’Œç¼–è¯‘LINPACK
if [ ! -f HPL-2.3.tar.gz ]; then
    wget http://www.netlib.org/benchmark/hpl/HPL-2.3.tar.gz
    tar -xzf HPL-2.3.tar.gz
fi

cd HPL-2.3

# é…ç½®ç¼–è¯‘
cp setup/Linux_PII_CBLAS Make.UNKNOWN
cd Make.UNKNOWN

# ç¼–è¾‘é…ç½®æ–‡ä»¶
sed -i 's/#define HPL_COPY_L_inplace 1/#define HPL_COPY_L_inplace 0/' Makefile
sed -i 's/CC = gcc/CC = gcc -O3 -march=native/' Makefile

# ç¼–è¯‘
make arch=UNKNOWN

# è¿è¡ŒåŸºå‡†æµ‹è¯•
echo "Running LINPACK benchmark..."
./xhpl
```

**SPEC CPUåŸºå‡†æµ‹è¯•**

```bash
#!/bin/bash
# /opt/performance/spec_cpu_benchmark.sh

echo "=== SPEC CPU Benchmark ==="

# æ£€æŸ¥SPEC CPUæ˜¯å¦å·²å®‰è£…
if [ ! -d "/opt/spec/cpu2017" ]; then
    echo "SPEC CPU2017 not found. Please install SPEC CPU2017 first."
    exit 1
fi

cd /opt/spec/cpu2017

# é…ç½®æµ‹è¯•
echo "Configuring SPEC CPU2017..."
./bin/runcpu --config=my_config.cfg --action setup --tune base --rate 1

# è¿è¡Œæ•´æ•°åŸºå‡†æµ‹è¯•
echo "Running SPECint_rate2017..."
./bin/runcpu --config=my_config.cfg --action run --tune base --rate 1 intspeed

# è¿è¡Œæµ®ç‚¹åŸºå‡†æµ‹è¯•
echo "Running SPECfp_rate2017..."
./bin/runcpu --config=my_config.cfg --action run --tune base --rate 1 fpspeed

# ç”ŸæˆæŠ¥å‘Š
echo "Generating results..."
./bin/runcpu --config=my_config.cfg --action report
```

**è‡ªå®šä¹‰CPUåŸºå‡†æµ‹è¯•**

```bash
#!/bin/bash
# /opt/performance/custom_cpu_benchmark.sh

echo "=== Custom CPU Benchmark ==="

# æµ®ç‚¹è¿ç®—æ€§èƒ½æµ‹è¯•
echo "Floating Point Performance Test:"
cat > fp_benchmark.c << 'EOF'
#include <stdio.h>
#include <time.h>
#include <math.h>

#define ITERATIONS 100000000

int main() {
    double result = 0.0;
    clock_t start, end;
    double cpu_time_used;

    start = clock();

    for (int i = 0; i < ITERATIONS; i++) {
        result += sin(i) * cos(i) + sqrt(i + 1);
    }

    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;

    printf("Result: %f\n", result);
    printf("Time: %f seconds\n", cpu_time_used);
    printf("Iterations per second: %f\n", ITERATIONS / cpu_time_used);

    return 0;
}
EOF

gcc -O3 -lm -o fp_benchmark fp_benchmark.c
./fp_benchmark
rm fp_benchmark fp_benchmark.c

# æ•´æ•°è¿ç®—æ€§èƒ½æµ‹è¯•
echo ""
echo "Integer Performance Test:"
cat > int_benchmark.c << 'EOF'
#include <stdio.h>
#include <time.h>

#define ITERATIONS 1000000000

int main() {
    unsigned long long result = 0;
    clock_t start, end;
    double cpu_time_used;

    start = clock();

    for (unsigned long long i = 1; i <= ITERATIONS; i++) {
        result += i * (i % 1000);
    }

    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;

    printf("Result: %llu\n", result);
    printf("Time: %f seconds\n", cpu_time_used);
    printf("Iterations per second: %f\n", ITERATIONS / cpu_time_used);

    return 0;
}
EOF

gcc -O3 -o int_benchmark int_benchmark.c
./int_benchmark
rm int_benchmark int_benchmark.c
```

#### 14.4.2 å†…å­˜åŸºå‡†æµ‹è¯•

**STREAMåŸºå‡†æµ‹è¯•**

```bash
#!/bin/bash
# /opt/performance/stream_benchmark.sh

echo "=== STREAM Memory Benchmark ==="

# ä¸‹è½½STREAM
if [ ! -f stream.c ]; then
    wget https://www.cs.virginia.edu/stream/FTP/Code/stream.c
fi

# ç¼–è¯‘
gcc -O3 -fopenmp -o stream stream.c

# è¿è¡Œæµ‹è¯•
echo "Running STREAM benchmark..."
./stream

# æ¸…ç†
rm -f stream stream.c
```

**å†…å­˜å¸¦å®½æµ‹è¯•**

```bash
#!/bin/bash
# /opt/performance/memory_bandwidth_test.sh

echo "=== Memory Bandwidth Test ==="

# ä½¿ç”¨iperf3æµ‹è¯•å†…å­˜å¸¦å®½ï¼ˆé€šè¿‡ç½‘ç»œï¼‰
echo "Testing memory bandwidth via network..."

# æœåŠ¡ç«¯
iperf3 -s & > /dev/null
SERVER_PID=$!
sleep 2

# å®¢æˆ·ç«¯æµ‹è¯•
echo "TCP Memory Bandwidth:"
iperf3 -c localhost -t 30 -P 4 -f M

echo ""
echo "UDP Memory Bandwidth:"
iperf3 -c localhost -u -b 10G -t 30 -P 4 -f M

# åœæ­¢æœåŠ¡ç«¯
kill $SERVER_PID

# æœ¬åœ°å†…å­˜å¸¦å®½æµ‹è¯•
echo ""
echo "Local Memory Bandwidth Test:"
cat > memory_bandwidth.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#define SIZE (1024 * 1024 * 256)  // 256MB
#define ITERATIONS 10

int main() {
    char *buffer = malloc(SIZE);
    if (!buffer) {
        printf("Memory allocation failed\n");
        return 1;
    }

    // å†™å…¥æµ‹è¯•
    clock_t start = clock();
    for (int i = 0; i < ITERATIONS; i++) {
        memset(buffer, 0xAA, SIZE);
    }
    clock_t end = clock();
    double write_time = ((double)(end - start)) / CLOCKS_PER_SEC;

    // è¯»å–æµ‹è¯•
    start = clock();
    volatile char dummy = 0;
    for (int i = 0; i < ITERATIONS; i++) {
        for (int j = 0; j < SIZE; j++) {
            dummy += buffer[j];
        }
    }
    end = clock();
    double read_time = ((double)(end - start)) / CLOCKS_PER_SEC;

    double write_bandwidth = (double)SIZE * ITERATIONS / write_time / 1024 / 1024;
    double read_bandwidth = (double)SIZE * ITERATIONS / read_time / 1024 / 1024;

    printf("Write Bandwidth: %.2f MB/s\n", write_bandwidth);
    printf("Read Bandwidth: %.2f MB/s\n", read_bandwidth);

    free(buffer);
    return 0;
}
EOF

gcc -O3 -o memory_bandwidth memory_bandwidth.c
./memory_bandwidth
rm memory_bandwidth memory_bandwidth.c
```

#### 14.4.3 å­˜å‚¨åŸºå‡†æµ‹è¯•

**FIOå­˜å‚¨åŸºå‡†æµ‹è¯•**

```bash
#!/bin/bash
# /opt/performance/fio_storage_benchmark.sh

echo "=== FIO Storage Benchmark ==="

# å®‰è£…FIO
if ! command -v fio &> /dev/null; then
    echo "Installing FIO..."
    yum install fio
fi

TEST_FILE="/tmp/fio_test_file"
TEST_SIZE="1G"

# åˆ›å»ºæµ‹è¯•æ–‡ä»¶
echo "Creating test file: $TEST_FILE ($TEST_SIZE)"
dd if=/dev/zero of=$TEST_FILE bs=1M count=1024

# é¡ºåºè¯»å–æµ‹è¯•
echo ""
echo "Sequential Read Test:"
fio --name=seq_read --filename=$TEST_FILE --rw=read --bs=1M --size=$TEST_SIZE --numjobs=4 --iodepth=64 --runtime=60 --time_based --group_reporting

# é¡ºåºå†™å…¥æµ‹è¯•
echo ""
echo "Sequential Write Test:"
fio --name=seq_write --filename=$TEST_FILE --rw=write --bs=1M --size=$TEST_SIZE --numjobs=4 --iodepth=64 --runtime=60 --time_based --group_reporting

# éšæœºè¯»å–æµ‹è¯•
echo ""
echo "Random Read Test:"
fio --name=rand_read --filename=$TEST_FILE --rw=randread --bs=4k --size=$TEST_SIZE --numjobs=4 --iodepth=64 --runtime=60 --time_based --group_reporting

# éšæœºå†™å…¥æµ‹è¯•
echo ""
echo "Random Write Test:"
fio --name=rand_write --filename=$TEST_FILE --rw=randwrite --bs=4k --size=$TEST_SIZE --numjobs=4 --iodepth=64 --runtime=60 --time_based --group_reporting

# æ¸…ç†æµ‹è¯•æ–‡ä»¶
rm -f $TEST_FILE
```

**LUSTREç‰¹å®šåŸºå‡†æµ‹è¯•**

```bash
#!/bin/bash
# /opt/performance/lustre_benchmark.sh

echo "=== LUSTRE Filesystem Benchmark ==="

if ! mount | grep -q lustre; then
    echo "LUSTRE filesystem not mounted"
    exit 1
fi

TEST_DIR="/scratch/fio_test"
TEST_SIZE="2G"

# åˆ›å»ºæµ‹è¯•ç›®å½•
mkdir -p $TEST_DIR

# è®¾ç½®LUSTREæ¡å¸¦åŒ–
echo "Setting LUSTRE striping for benchmark..."
lfs setstripe -c -1 $TEST_DIR

# LUSTREç‰¹å®šæµ‹è¯•
echo ""
echo "LUSTRE Sequential Read:"
fio --name=seq_read_lustre --filename=$TEST_DIR/seq_read.dat --rw=read --bs=1M --size=$TEST_SIZE --numjobs=8 --iodepth=128 --runtime=120 --time_based --group_reporting

echo ""
echo "LUSTRE Sequential Write:"
fio --name=seq_write_lustre --filename=$TEST_DIR/seq_write.dat --rw=write --bs=1M --size=$TEST_SIZE --numjobs=8 --iodepth=128 --runtime=120 --time_based --group_reporting

echo ""
echo "LUSTRE Random Read:"
fio --name=rand_read_lustre --filename=$TEST_DIR/rand_read.dat --rw=randread --bs=4k --size=$TEST_SIZE --numjobs=8 --iodepth=128 --runtime=120 --time_based --group_reporting

# æ¸…ç†æµ‹è¯•æ–‡ä»¶
rm -rf $TEST_DIR
```

#### 14.4.4 ç½‘ç»œåŸºå‡†æµ‹è¯•

**MPIåŸºå‡†æµ‹è¯•**

```bash
#!/bin/bash
# /opt/performance/mpi_benchmark.sh

echo "=== MPI Benchmark ==="

# ä¸‹è½½å’Œç¼–è¯‘OSU Micro-Benchmarks
if [ ! -d "osu-micro-benchmarks-5.8" ]; then
    wget http://mvapich.cse.ohio-state.edu/download/mvapich/osu-micro-benchmarks-5.8.tar.gz
    tar -xzf osu-micro-benchmarks-5.8.tar.gz
    cd osu-micro-benchmarks-5.8
    ./configure --prefix=/opt/osu-benchmarks --enable-shared --disable-fortran
    make
    make install
fi

# ç‚¹å¯¹ç‚¹é€šä¿¡åŸºå‡†æµ‹è¯•
echo "Point-to-Point Communication Benchmarks:"
cd /opt/osu-benchmarks/libexec/osu-micro-benchmarks/mpi/pt2pt

echo "Latency Test:"
mpirun -np 2 ./osu_latency

echo ""
echo "Bandwidth Test:"
mpirun -np 2 ./osu_bw

echo ""
echo "All-to-All Communication:"
mpirun -np 4 ./osu_alltoall

# é›†åˆé€šä¿¡åŸºå‡†æµ‹è¯•
echo ""
echo "Collective Communication Benchmarks:"
cd /opt/osu-benchmarks/libexec/osu-micro-benchmarks/mpi/collective

echo "Allreduce Test:"
mpirun -np 8 ./osu_allreduce

echo ""
echo "Allgather Test:"
mpirun -np 8 ./osu_allgather

echo ""
echo "Barrier Test:"
mpirun -np 8 ./osu_barrier
```

**ç½‘ç»œå»¶è¿Ÿå’Œå¸¦å®½æµ‹è¯•**

```bash
#!/bin/bash
# /opt/performance/network_latency_bandwidth_test.sh

echo "=== Network Latency and Bandwidth Test ==="

# è·å–é›†ç¾¤èŠ‚ç‚¹åˆ—è¡¨
NODES=$(scontrol show hostnames)

echo "Testing network performance between cluster nodes..."

# æµ‹è¯•å»¶è¿Ÿ
echo ""
echo "Network Latency Test:"
for node in $NODES; do
    if [ "$node" != "$(hostname)" ]; then
        echo "Testing latency to $node:"
        ping -c 10 $node | tail -1 | awk -F'/' '{print "Avg latency: " $5 " ms"}'
    fi
done

# æµ‹è¯•å¸¦å®½
echo ""
echo "Network Bandwidth Test:"
for node in $NODES; do
    if [ "$node" != "$(hostname)" ]; then
        echo "Testing bandwidth to $node:"
        iperf3 -c $node -t 30 -f M | grep "sender" | awk '{print "Bandwidth: " $7 " " $8}'
    fi
done
```

#### 14.4.5 HPCåº”ç”¨åŸºå‡†æµ‹è¯•

**NAMDåˆ†å­åŠ¨åŠ›å­¦åŸºå‡†æµ‹è¯•**

```bash
#!/bin/bash
# /opt/performance/namd_benchmark.sh

echo "=== NAMD Molecular Dynamics Benchmark ==="

# ä¸‹è½½NAMDåŸºå‡†æµ‹è¯•
if [ ! -d "apoa1" ]; then
    wget http://www.ks.uiuc.edu/Research/namd/utilities/apoa1.tar.gz
    tar -xzf apoa1.tar.gz
fi

cd apoa1

# è¿è¡ŒNAMDåŸºå‡†æµ‹è¯•
echo "Running NAMD benchmark..."
mpirun -np 16 namd2 apoa1.namd > apoa1.out

# åˆ†æç»“æœ
echo ""
echo "NAMD Performance Results:"
grep "Performance" apoa1.out

# æ¸…ç†
cd ..
rm -rf apoa1
```

**GROMACSåŸºå‡†æµ‹è¯•**

```bash
#!/bin/bash
# /opt/performance/gromacs_benchmark.sh

echo "=== GROMACS Benchmark ==="

# ä¸‹è½½GROMACSåŸºå‡†æµ‹è¯•
if [ ! -f "ADH_dodec_1ns.tpr" ]; then
    echo "Please provide a GROMACS benchmark .tpr file"
    exit 1
fi

# è¿è¡ŒGROMACSåŸºå‡†æµ‹è¯•
echo "Running GROMACS benchmark..."
mdrun -ntmpi 16 -ntomp 4 -s ADH_dodec_1ns.tpr -nsteps 1000

# åˆ†ææ€§èƒ½
echo ""
echo "GROMACS Performance Analysis:"
grep "Performance" md.log
grep "Time" md.log
```

### 14.5 æ€§èƒ½ä¼˜åŒ–æ¡ˆä¾‹

#### 14.5.1 CPUå¯†é›†å‹åº”ç”¨ä¼˜åŒ–

**æ¡ˆä¾‹ï¼šCFDè®¡ç®—ä¼˜åŒ–**

```bash
#!/bin/bash
# /opt/performance/cfd_optimization_case.sh

echo "=== CFD Application Optimization Case ==="

# 1. ç¼–è¯‘å™¨ä¼˜åŒ–
echo "1. Compiler Optimization:"
echo "Using Intel Compiler with optimization flags:"
echo "icc -O3 -xHost -ipo -parallel -qopenmp cfd_solver.c"

# 2. å¹¶è¡ŒåŒ–ä¼˜åŒ–
echo ""
echo "2. Parallelization Optimization:"
echo "OpenMP thread affinity:"
export OMP_NUM_THREADS=16
export KMP_AFFINITY=granularity=fine,compact,1,0
export KMP_SETTINGS=1

# 3. å†…å­˜è®¿é—®ä¼˜åŒ–
echo ""
echo "3. Memory Access Optimization:"
echo "Array layout optimization for cache efficiency:"
cat << 'EOF'
// Cache-friendly array access
for (int i = 0; i < NX; i++) {
    for (int j = 0; j < NY; j++) {
        for (int k = 0; k < NZ; k++) {
            // Sequential memory access pattern
            u[i][j][k] = compute_value(i, j, k);
        }
    }
}
EOF

# 4. å‘é‡åŒ–ä¼˜åŒ–
echo ""
echo "4. Vectorization Optimization:"
echo "SIMD optimization with compiler directives:"
cat << 'EOF'
#pragma omp parallel for simd collapse(3)
for (int i = 0; i < NX; i++) {
    for (int j = 0; j < NY; j++) {
        for (int k = 0; k < NZ; k++) {
            u[i][j][k] = a[i][j][k] + b[i][j][k];
        }
    }
}
EOF

# 5. æ€§èƒ½æµ‹è¯•
echo ""
echo "5. Performance Testing:"
echo "Running optimized CFD solver..."
time mpirun -np 32 ./cfd_solver_optimized
```

#### 14.5.2 å†…å­˜å¯†é›†å‹åº”ç”¨ä¼˜åŒ–

**æ¡ˆä¾‹ï¼šå¤§æ•°æ®å¤„ç†ä¼˜åŒ–**

```bash
#!/bin/bash
# /opt/performance/bigdata_optimization_case.sh

echo "=== Big Data Processing Optimization Case ==="

# 1. å†…å­˜åˆ†é…ä¼˜åŒ–
echo "1. Memory Allocation Optimization:"
echo "NUMA-aware memory allocation:"
cat << 'EOF'
// NUMA-aware allocation
#include <numa.h>
#include <numaif.h>

void* numa_aware_malloc(size_t size, int node) {
    void* ptr = numa_alloc_onnode(size, node);
    if (ptr) {
        // è®¾ç½®å†…å­˜ç­–ç•¥
        mbind(ptr, size, MPOL_BIND, NULL, 0, MPOL_MF_MOVE);
    }
    return ptr;
}
EOF

# 2. æ•°æ®ç»“æ„ä¼˜åŒ–
echo ""
echo "2. Data Structure Optimization:"
echo "Cache-friendly data structures:"
cat << 'EOF'
// Structure of Arrays (SoA) instead of Array of Structures (AoS)
struct Particle {
    float x[1000];  // X coordinates
    float y[1000];  // Y coordinates
    float z[1000];  // Z coordinates
    float vx[1000]; // X velocities
    float vy[1000]; // Y velocities
    float vz[1000]; // Z velocities
};
EOF

# 3. å†…å­˜é¢„å–ä¼˜åŒ–
echo ""
echo "3. Memory Prefetching Optimization:"
cat << 'EOF'
// Software prefetching for sequential access
for (int i = 0; i < N; i++) {
    __builtin_prefetch(&data[i + 32], 0, 3);  // Prefetch 32 elements ahead
    process(data[i]);
}
EOF

# 4. å¤§é¡µå†…å­˜ä½¿ç”¨
echo ""
echo "4. Huge Pages Optimization:"
echo "Configuring transparent huge pages:"
echo "echo always > /sys/kernel/mm/transparent_hugepage/enabled"
echo "echo madvise > /sys/kernel/mm/transparent_hugepage/defrag"
```

#### 14.5.3 I/Oå¯†é›†å‹åº”ç”¨ä¼˜åŒ–

**æ¡ˆä¾‹ï¼šç§‘å­¦æ•°æ®å¤„ç†ä¼˜åŒ–**

```bash
#!/bin/bash
# /opt/performance/io_intensive_optimization_case.sh

echo "=== I/O Intensive Application Optimization Case ==="

# 1. å¹¶è¡ŒI/Oä¼˜åŒ–
echo "1. Parallel I/O Optimization:"
echo "Using MPI-IO for parallel file access:"
cat << 'EOF'
#include <mpi.h>

// Parallel file I/O with MPI-IO
MPI_File file;
MPI_File_open(MPI_COMM_WORLD, "data.dat", MPI_MODE_RDONLY, MPI_INFO_NULL, &file);

// Set file view for data distribution
MPI_File_set_view(file, offset, MPI_DOUBLE, MPI_DOUBLE, "native", MPI_INFO_NULL);

// Collective read operation
MPI_File_read_all(file, buffer, count, MPI_DOUBLE, MPI_STATUS_IGNORE);

MPI_File_close(&file);
EOF

# 2. ç¼“å­˜ä¼˜åŒ–
echo ""
echo "2. Cache Optimization:"
echo "Implementing multi-level caching:"
cat << 'EOF'
// Application-level caching
#define CACHE_SIZE (1024 * 1024 * 256)  // 256MB cache
static char* read_cache = NULL;
static size_t cache_offset = 0;

void init_cache() {
    read_cache = malloc(CACHE_SIZE);
    // Pre-read frequently accessed data
    preload_frequent_data();
}

void* get_data_block(size_t offset, size_t size) {
    // Check cache first
    if (offset >= cache_offset && offset < cache_offset + CACHE_SIZE) {
        return read_cache + (offset - cache_offset);
    }
    // Cache miss - read from disk
    return read_from_disk(offset, size);
}
EOF

# 3. æ–‡ä»¶ç³»ç»Ÿä¼˜åŒ–
echo ""
echo "3. Filesystem Optimization:"
echo "LUSTRE striping for optimal I/O performance:"
echo "lfs setstripe -c 8 -s 1M /path/to/data/directory"
echo "lfs setstripe -c -1 /path/to/output/directory"

# 4. å¼‚æ­¥I/Oä¼˜åŒ–
echo ""
echo "4. Asynchronous I/O Optimization:"
cat << 'EOF'
// POSIX AIO for asynchronous operations
#include <aio.h>

struct aiocb aio_request;
memset(&aio_request, 0, sizeof(aio_request));
aio_request.aio_fildes = fd;
aio_request.aio_buf = buffer;
aio_request.aio_nbytes = size;
aio_request.aio_offset = offset;

// Submit asynchronous read
aio_read(&aio_request);

// Continue with computation while I/O proceeds
perform_computation();

// Wait for I/O completion
aio_suspend(&aio_request, 1, NULL);
EOF
```

## ğŸ“š æœ€ä½³å®è·µ

### 14.6 æ€§èƒ½ä¼˜åŒ–åŸåˆ™

#### 14.6.1 ä¼˜åŒ–ç­–ç•¥ä¼˜å…ˆçº§

1. **ç®—æ³•ä¼˜åŒ–**ï¼šé€‰æ‹©æ›´é«˜æ•ˆçš„ç®—æ³•å’Œæ•°æ®ç»“æ„
2. **å¹¶è¡ŒåŒ–ä¼˜åŒ–**ï¼šåˆ©ç”¨å¤šæ ¸å’Œåˆ†å¸ƒå¼è®¡ç®—
3. **å†…å­˜ä¼˜åŒ–**ï¼šæ”¹å–„ç¼“å­˜å‘½ä¸­ç‡å’Œå†…å­˜è®¿é—®æ¨¡å¼
4. **I/Oä¼˜åŒ–**ï¼šå‡å°‘I/Oæ“ä½œï¼Œæé«˜I/Oæ•ˆç‡
5. **ç¼–è¯‘å™¨ä¼˜åŒ–**ï¼šä½¿ç”¨åˆé€‚çš„ç¼–è¯‘å™¨å’Œä¼˜åŒ–é€‰é¡¹

#### 14.6.2 æ€§èƒ½åˆ†ææ–¹æ³•

1. **è‡ªé¡¶å‘ä¸‹åˆ†æ**ï¼šä»åº”ç”¨æ€§èƒ½å¼€å§‹ï¼Œé€æ­¥æ·±å…¥åˆ°ç³»ç»Ÿå±‚é¢
2. **ç“¶é¢ˆè¯†åˆ«**ï¼šæ‰¾åˆ°é™åˆ¶æ€§èƒ½çš„å…³é”®å› ç´ 
3. **é‡åŒ–æ”¹è¿›**ï¼šæ¯æ¬¡ä¼˜åŒ–éƒ½è¦æµ‹é‡æ”¹è¿›æ•ˆæœ
4. **å›å½’æµ‹è¯•**ï¼šç¡®ä¿ä¼˜åŒ–ä¸ä¼šå¼•å…¥æ–°çš„é—®é¢˜

#### 14.6.3 æŒç»­ä¼˜åŒ–æµç¨‹

```bash
#!/bin/bash
# /opt/performance/continuous_optimization.sh

echo "=== Continuous Performance Optimization Process ==="

# 1. åŸºå‡†æµ‹è¯•
echo "1. Establishing baseline performance..."
./benchmark_suite.sh > baseline_results.txt

# 2. æ€§èƒ½ç›‘æ§
echo "2. Continuous performance monitoring..."
/opt/performance/one_click_diagnose.sh > current_performance.txt

# 3. ç“¶é¢ˆè¯†åˆ«
echo "3. Bottleneck identification..."
/opt/performance/cpu_bottleneck.sh > cpu_analysis.txt
/opt/performance/memory_bottleneck.sh > memory_analysis.txt
/opt/performance/io_bottleneck.sh > io_analysis.txt

# 4. ä¼˜åŒ–å®æ–½
echo "4. Optimization implementation..."
# æ ¹æ®åˆ†æç»“æœå®æ–½ä¼˜åŒ–

# 5. æ•ˆæœéªŒè¯
echo "5. Performance validation..."
./benchmark_suite.sh > optimized_results.txt

# 6. å›å½’æµ‹è¯•
echo "6. Regression testing..."
./regression_test_suite.sh

# 7. æ–‡æ¡£æ›´æ–°
echo "7. Documentation update..."
echo "Optimization completed at $(date)" >> optimization_log.txt
```

## ğŸ“ æœ¬ç« æ€»ç»“

æ€§èƒ½ä¼˜åŒ–æ˜¯HPCè¿ç»´çš„æ ¸å¿ƒæŠ€èƒ½ï¼Œé€šè¿‡æœ¬ç« å­¦ä¹ ï¼Œä½ åº”è¯¥èƒ½å¤Ÿï¼š

- âœ… ç†Ÿç»ƒä½¿ç”¨å„ç§æ€§èƒ½åˆ†æå·¥å…·ï¼ˆperfã€vmstatã€iostatç­‰ï¼‰
- âœ… ç³»ç»ŸåŒ–è¯†åˆ«å’Œåˆ†ææ€§èƒ½ç“¶é¢ˆï¼ˆCPUã€å†…å­˜ã€I/Oã€ç½‘ç»œï¼‰
- âœ… åˆ¶å®šå’Œå®æ–½æœ‰æ•ˆçš„æ€§èƒ½ä¼˜åŒ–ç­–ç•¥
- âœ… å»ºç«‹å®Œæ•´çš„æ€§èƒ½åŸºå‡†æµ‹è¯•ä½“ç³»
- âœ… å¤„ç†å„ç§HPCåº”ç”¨åœºæ™¯çš„æ€§èƒ½ä¼˜åŒ–

æ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦ç»“åˆå…·ä½“çš„åº”ç”¨åœºæ™¯å’Œç¡¬ä»¶ç¯å¢ƒï¼Œé‡‡ç”¨ç³»ç»ŸåŒ–çš„æ–¹æ³•è¿›è¡Œåˆ†æå’Œæ”¹è¿›ã€‚

## ğŸ“ ç»ƒä¹ é¢˜

1. **å®è·µé¢˜**ï¼šä¸ºä½ çš„é›†ç¾¤å»ºç«‹å®Œæ•´çš„æ€§èƒ½ç›‘æ§ä½“ç³»
2. **åˆ†æé¢˜**ï¼šä½¿ç”¨perfå·¥å…·åˆ†æä¸€ä¸ªå®é™…åº”ç”¨çš„æ€§èƒ½ç“¶é¢ˆ
3. **ä¼˜åŒ–é¢˜**ï¼šé’ˆå¯¹ç‰¹å®šåº”ç”¨åœºæ™¯å®æ–½æ€§èƒ½ä¼˜åŒ–å¹¶éªŒè¯æ•ˆæœ
4. **è®¾è®¡é¢˜**ï¼šè®¾è®¡ä¸€ä¸ªåŒ…å«å¤šç§åŸºå‡†æµ‹è¯•çš„æ€§èƒ½è¯„ä¼°æ–¹æ¡ˆ

## ğŸ”— å‚è€ƒèµ„æº

- [Linux Performance Analysis](https://www.brendangregg.com/linuxperf.html)
- [Intel VTune Profiler](https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler.html)
- [LLVM Performance Analysis](https://llvm.org/docs/HowToSubmitABug.html)
- [HPC Benchmarking Standards](https://www.top500.org/lists/hpcg/)